[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Metaheuristics in Java",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "Algorithms\n\nGA: Genetic Algorithm\nSA: Simulated Annealing\nTS: Tabu Search\n\nProblems\n\nGAP: Generalized Assignment Problem\n\n\n\n\n\nGA\nSA\nTS\n\n\n\n\nGAP\n[ ]\n[ ]\n\n\n\n-\n[ ]\n[ ]\n[ ]\n\n\n-\n[ ]\n[ ]\n[ ]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "workflow-ts.html",
    "href": "workflow-ts.html",
    "title": "4  Tabu Search Workflow",
    "section": "",
    "text": "4.1 Algorithm Workflow and Key Steps\nTabu Search is a metaheuristic algorithm used for solving combinatorial optimization problems. It was proposed by Fred Glover in 1986. The primary idea behind Tabu Search is to iteratively explore the solution space in search of the optimal or near-optimal solution by intelligently navigating through the space of feasible solutions.\nHere’s a high-level explanation of how the Tabu Search algorithm works:\nTabu Search is known for its ability to efficiently explore complex solution spaces, often outperforming other traditional optimization techniques. It’s widely used in various domains, including operations research, scheduling, logistics, and engineering design, among others.\nFigure 4.1 shows the workflow of Tabu Search. After creating and evaluating the initial solution, Tabu search requires an iterative process of neighborhood solution generation, tabu/aspiration criteria checking and next solution selection to approximate the optimal solutions.\ngraph TD;\n    A[Initialization] --&gt; B[Generate Initial Solution];\n    B --&gt; C[Evaluate Solution];\n    C --&gt; D[Generate Neighboring Solutions];\n    D --&gt; E[Evaluate Neighboring Solutions];\n    E --&gt; F[Tabu Criteria];\n    F --&gt; G[Aspiration Criteria];\n    G --&gt; H[Select Next Solution];\n    H --&gt; I[Termination Condition];\n    I --&gt; J[Output];\n    J --&gt; D;\n\n\n\n\nFigure 4.1: Tabu search algorithm workflow",
    "crumbs": [
      "Algorithm Workflow",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tabu Search Workflow</span>"
    ]
  },
  {
    "objectID": "workflow-ts.html#algorithm-workflow-and-key-steps",
    "href": "workflow-ts.html#algorithm-workflow-and-key-steps",
    "title": "4  Tabu Search Workflow",
    "section": "",
    "text": "Initialization:\n\nStart with an initial solution, which can be generated randomly or through some heuristic method.\nInitialize a Tabu list to keep track of previously visited solutions.\n\nGenerating Neighboring Solutions:\n\nGenerate neighboring solutions by making small modifications to the current solution. These modifications could involve swapping, inserting, deleting, or otherwise altering elements of the current solution.\nNeighboring solutions are usually generated based on some predefined neighborhood structure specific to the problem being solved.\n\nEvaluating Neighboring Solutions:\n\nEvaluate each neighboring solution using an objective function that measures the quality of the solution.\nThe objective function reflects the optimization criteria of the problem, such as minimizing cost, maximizing profit, etc.\n\nTabu Criteria:\n\nIntroduce Tabu criteria to determine which neighboring solutions are permissible for exploration.\nThe Tabu list contains information about recent moves or solutions that are prohibited from being selected in the current iteration. This prevents the algorithm from revisiting solutions that have already been explored or to avoid getting stuck in local optima.\n\nAspiration Criteria:\n\nIn some cases, solutions in the Tabu list may be revisited if they lead to a significant improvement over the current best solution. This is governed by aspiration criteria, which allow certain Tabu moves under specific circumstances.\n\nUpdating Tabu List:\n\nUpdate the Tabu list to reflect the recent moves or solutions that have been explored. This ensures that the algorithm avoids cycling through the same solutions repeatedly.\n\nSelecting Next Solution:\n\nChoose the next solution to explore based on a combination of factors, including the quality of the solution, Tabu status, aspiration criteria, and possibly randomization to encourage exploration.\n\nTermination Condition:\n\nRepeat the above steps iteratively until a termination condition is met. This condition could be a maximum number of iterations, reaching a predefined solution quality threshold, or running out of computational resources.\n\nOutput:\n\nReturn the best solution found during the search process.",
    "crumbs": [
      "Algorithm Workflow",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tabu Search Workflow</span>"
    ]
  },
  {
    "objectID": "workflow-ts.html#key-considerations",
    "href": "workflow-ts.html#key-considerations",
    "title": "4  Tabu Search Workflow",
    "section": "4.2 Key Considerations",
    "text": "4.2 Key Considerations\nWhen implementing the Tabu Search algorithm to solve optimization problems, there are several important aspects to consider to ensure its effectiveness and efficiency:\n\nProblem Representation: Choose an appropriate representation of solutions for the optimization problem at hand. The representation should allow easy manipulation and evaluation of solutions.\nObjective Function: Define a clear and appropriate objective function that quantifies the quality of solutions based on the problem requirements. This function guides the search for optimal or near-optimal solutions.\nNeighborhood Structure: Design a neighborhood structure that defines how neighboring solutions are generated from the current solution. This structure greatly influences the search process and should allow for efficient exploration of the solution space.\nTabu List Management: Implement an efficient mechanism to manage the Tabu list, which keeps track of recent moves or solutions that are prohibited from being revisited. Consider factors such as Tabu tenure (how long a move remains prohibited), size of the Tabu list, and strategies for updating and clearing the list.\nAspiration Criteria: Define aspiration criteria to determine when to override Tabu restrictions based on certain conditions, such as significant improvements in solution quality.\nDiversification Strategies: Incorporate diversification strategies to ensure exploration of diverse regions of the solution space. This helps prevent the algorithm from getting stuck in local optima.\nIntensification Strategies: Implement intensification strategies to focus the search on promising regions of the solution space, especially as the algorithm progresses. This may involve prioritizing certain types of moves or solutions.\nTermination Criteria: Define appropriate termination criteria to determine when to stop the search process. This could be based on reaching a maximum number of iterations, a specified solution quality threshold, or other factors.\nParameter Tuning: Experiment with different parameter settings, such as Tabu tenure, neighborhood size, and aspiration criteria thresholds, to find the most effective configurations for the specific problem being solved.\nEfficient Data Structures and Algorithms: Use efficient data structures and algorithms for solution representation, neighborhood generation, and Tabu list management to optimize the computational performance of the algorithm.\nValidation and Testing: Validate the implementation by testing it on a variety of problem instances with known optimal solutions, if available. This helps verify the correctness and effectiveness of the algorithm.\n\nBy paying attention to these aspects when implementing the Tabu Search algorithm, we can enhance its performance and increase the likelihood of finding high-quality solutions to optimization problems.\nIn the remaining chapters of this book, we will apply Tabu Search to solve various optimization problems to demonstrate some of aforementioned points.",
    "crumbs": [
      "Algorithm Workflow",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tabu Search Workflow</span>"
    ]
  },
  {
    "objectID": "gap-intro.html",
    "href": "gap-intro.html",
    "title": "5  Generalized Assignment Problem",
    "section": "",
    "text": "5.1 Problem Statement\nFormally, the Generalized Assignment Problem can be defined as follows:\nGiven:\nThe goal is to find an assignment of tasks to agents that minimizes the total cost or maximizes the total profit, while ensuring that each task is assigned to one or more agents, and the total resource requirement of each agent does not exceed its capacity.\nMathematically, the GAP can be formulated as an integer linear programming problem. One possible formulation is as follows:\n\\[\n\\begin{aligned}\n\\text{min.} &\\quad \\sum_{i=1}^{n} \\sum_{j=1}^{m} c_{ij} x_{ij} \\label{gap-obj}\\\\\n\\text{s.t.} &\\quad \\sum_{j=1}^{m} x_{ij} = 1, \\ \\forall i = 1, 2, ..., n \\label{gap-cons1}\\\\\n&\\quad \\sum_{i=1}^{n} r_{ij} x_{ij} \\leq b_j, \\  \\forall j = 1, 2, ..., m \\label{gap-cons2}\\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall i = 1, 2, ..., n, j = 1, 2, ..., m \\label{gap-cons3}\n\\end{aligned}\n\\]\nwhere \\(x_{ij}\\) is a binary decision variable that equals 1 if task \\(i\\) is assigned to agent \\(j\\), and 0 otherwise.\nThe first set of constraints ensures that each task is assigned to exactly one agent, and the second set of constraints ensures that the total resource requirement of each agent does not exceed its capacity.\nSolving the GAP can be computationally challenging, especially for large instances, as it is a generalization of the classic assignment problem, which is known to be polynomial-time solvable. Various algorithms and heuristics, such as branch and bound, dynamic programming, and approximation algorithms, can be employed to find feasible or optimal solutions to the GAP.",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "gap-intro.html#problem-statement",
    "href": "gap-intro.html#problem-statement",
    "title": "5  Generalized Assignment Problem",
    "section": "",
    "text": "A set of tasks, \\(T = \\{1, 2, ..., n\\}\\)\nA set of agents, \\(A = \\{1, 2, ..., m\\}\\)\nFor each task \\(i\\) and agent \\(j\\), a cost or profit \\(c_{ij}\\) associated with assigning task \\(i\\) to agent \\(j\\)\nFor each task \\(i\\) and agent \\(j\\), a resource requirement \\(r_{ij}\\) specifying the amount of resource needed from agent \\(j\\) to complete task \\(i\\)\nFor each agent \\(j\\), a capacity \\(b_j\\) specifying the maximum amount of resource that agent \\(j\\) can contribute",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "gap-intro.html#benchmarking-problems",
    "href": "gap-intro.html#benchmarking-problems",
    "title": "5  Generalized Assignment Problem",
    "section": "5.2 Benchmarking Problems",
    "text": "5.2 Benchmarking Problems",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "gap-ts.html",
    "href": "gap-ts.html",
    "title": "8  Tabu Search for GAP",
    "section": "",
    "text": "8.1 Algorithm Design",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tabu Search for GAP</span>"
    ]
  },
  {
    "objectID": "gap-ts.html#algorithm-design",
    "href": "gap-ts.html#algorithm-design",
    "title": "8  Tabu Search for GAP",
    "section": "",
    "text": "8.1.1 Solution representation\n\n\n8.1.2 Neighborhood structure\n\n\n8.1.3 Tabu table design",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tabu Search for GAP</span>"
    ]
  },
  {
    "objectID": "gap-ts.html#implementation-in-java",
    "href": "gap-ts.html#implementation-in-java",
    "title": "8  Tabu Search for GAP",
    "section": "8.2 Implementation in Java",
    "text": "8.2 Implementation in Java\nIn this section, we present an implementation of Tabu Search in Java.\n\n8.2.1 Source file structure\nsrc/main/java\n└── com\n    └── voyager\n        └── opt\n            └── metaheuristics\n                ├── gap\n                │   ├── GapInstance.java\n                │   ├── GapInstanceReader.java\n                │   ├── GapSolution.java\n                │   └── tabu\n                │       ├── GapSolutionNeighbor.java\n                │       └── GapTabuSearch.java\n                └── utils\n                    ├── PerfRecord.java\n                    └── PerfRecordsWriter.java\n\n\n8.2.2 Java classes and explanations\n\n\nGapInstance.java\n\npackage com.voyager.opt.metaheuristics.gap;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\n\n@Data\n@Builder\n@AllArgsConstructor\npublic class GapInstance {\n  /**\n   * total number of tasks\n   */\n  private int numTasks;\n  /**\n   * total number of agents\n   */\n  private int numAgents;\n  /**\n   * costs of assigning tasks to agents\n   */\n  private int[][] costs;\n  /**\n   * resource consumption of assigning tasks to agents\n   */\n  private int[][] resources;\n  /**\n   * agent capacities\n   */\n  private int[] capacities;\n}\n\n\n\nGapSolution.java\n\npackage com.voyager.opt.metaheuristics.gap;\n\nimport lombok.Getter;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.stream.IntStream;\n\n@Getter\npublic final class GapSolution {\n  /**\n   * reference to the instance to be solved\n   */\n  private final GapInstance instance;\n  /**\n   * dimension: 1 * numTasks\n   * assigned agent index for each task\n   */\n  private final int[] agentAssignments;\n  /**\n   * dimension: 1 * numAgents\n   * consumed capacity of each agent\n   */\n  private final int[] consumedCapacities;\n  /**\n   * total objective value\n   */\n  private int objective;\n  /**\n   * assignment cost, without penalties\n   */\n  private int assignmentCost;\n  /**\n   * capacity violation penalties of all agents\n   */\n  private int capacityViolationPenalty;\n\n  public GapSolution(GapInstance instance) {\n    this.instance = instance;\n    this.agentAssignments = new int[this.instance.getNumTasks()];\n    this.consumedCapacities = new int[this.instance.getNumAgents()];\n    Arrays.fill(this.agentAssignments, 0);\n    Arrays.fill(consumedCapacities, 0);\n    this.objective = 0;\n    this.assignmentCost = 0;\n    this.capacityViolationPenalty = 0;\n  }\n\n  /**\n   * copy constructor\n   * @param other the other solution to copy from\n   */\n  public GapSolution(GapSolution other) {\n    this.instance = other.instance;\n    this.agentAssignments = new int[this.instance.getNumTasks()];\n    System.arraycopy(other.agentAssignments, 0,\n      this.agentAssignments, 0,\n      this.instance.getNumTasks());\n    this.consumedCapacities = new int[this.instance.getNumAgents()];\n    System.arraycopy(other.consumedCapacities, 0,\n      this.consumedCapacities, 0,\n      this.instance.getNumAgents());\n    this.objective = other.objective;\n    this.assignmentCost = other.assignmentCost;\n    this.capacityViolationPenalty = other.capacityViolationPenalty;\n  }\n\n  /**\n   * randomly assign tasks to agents\n   * @param random random number generator\n   */\n  public void initialize(Random random) {\n    int[][] resources = this.instance.getResources();\n    for (int i = 0; i &lt; instance.getNumTasks(); i++) {\n      int agentIdx = random.nextInt(instance.getNumAgents());\n      this.agentAssignments[i] = agentIdx;\n      this.consumedCapacities[agentIdx] += resources[agentIdx][i];\n    }\n  }\n\n  /**\n   * compute objective values\n   * @param capacityViolationPenalty penalty factor\n   */\n  public void computeObjective(int capacityViolationPenalty) {\n    // compute assignment costs\n    this.assignmentCost = IntStream.range(0, instance.getNumTasks())\n      .map(taskIdx -&gt; instance.getCosts()[agentAssignments[taskIdx]][taskIdx])\n      .sum();\n\n    // compute capacity violation costs\n    this.capacityViolationPenalty = IntStream.range(0, instance.getNumAgents())\n      .map(agentIdx -&gt; capacityViolationPenalty *\n        Math.max(0, this.consumedCapacities[agentIdx] - instance.getCapacities()[agentIdx]))\n      .sum();\n\n    this.objective = this.assignmentCost + this.capacityViolationPenalty;\n  }\n\n  public int getAssignedAgent(int taskIdx) {\n    return this.agentAssignments[taskIdx];\n  }\n\n  /**\n   * assign agent to task\n   * @param taskIdx the task to be assigned\n   * @param agentIdx the agent index\n   */\n  public void setAssignedAgent(int taskIdx, int agentIdx) {\n    int currAgentIdx = this.agentAssignments[taskIdx];\n    this.agentAssignments[taskIdx] = agentIdx;\n    this.consumedCapacities[currAgentIdx] -= instance.getResources()[currAgentIdx][taskIdx];\n    this.consumedCapacities[agentIdx] += instance.getResources()[agentIdx][taskIdx];\n  }\n}\n\n\n\nGapSolutionNeighbor.java\n\npackage com.voyager.opt.metaheuristics.gap.tabu;\n\nimport com.voyager.opt.metaheuristics.gap.GapSolution;\nimport lombok.Builder;\nimport lombok.Getter;\n\n@Getter\n@Builder\npublic class GapSolutionNeighbor {\n  /**\n   * neighboring solution\n   */\n  private GapSolution newSolution;\n  /**\n   * the task for which agent assignment is changed\n   */\n  private int mutatedTaskIdx;\n  /**\n   * new agent index for the chosen task\n   */\n  private int newAgentIdx;\n}\n\n\n\nGapTabuSearch\n\npackage com.voyager.opt.metaheuristics.gap.tabu;\n\nimport com.voyager.opt.metaheuristics.gap.GapInstance;\nimport com.voyager.opt.metaheuristics.gap.GapInstanceReader;\nimport com.voyager.opt.metaheuristics.gap.GapSolution;\nimport com.voyager.opt.metaheuristics.utils.PerfRecord;\nimport com.voyager.opt.metaheuristics.utils.PerfRecordsWriter;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.*;\n\n@Getter\n@Setter\npublic final class GapTabuSearch {\n  /**\n   * instance to be solved\n   */\n  private final GapInstance instance;\n  /**\n   * random number generator\n   */\n  private final Random random;\n  /**\n   * tabu table\n   */\n  private final int[][] tabuTable;\n  /**\n   * best solution\n   */\n  private GapSolution bestSolution;\n  private List&lt;PerfRecord&lt;Integer&gt;&gt; perfRecords;\n\n  public GapTabuSearch(GapInstance instance) {\n    this.instance = instance;\n    this.random = new Random(42);\n    int numTasks = instance.getNumTasks();\n    this.tabuTable = new int[numTasks][instance.getNumAgents()];\n    for (int i = 0; i &lt; numTasks; i++) {\n      Arrays.fill(this.tabuTable[i], 0);\n    }\n\n    this.bestSolution = null;\n    this.perfRecords = new ArrayList&lt;&gt;();\n  }\n\n  public void solve() {\n    // penalty factor for capacity violation\n    int capacityViolationPenalty = 1000;\n\n    // tabu search parameters\n    int neighSize = 100;\n    int tabuLength = 100;\n\n    // stopping criteria\n    int maxIter = 2000;\n    int maxIterNoImprove = 500;\n\n    // create a starting solution\n    GapSolution currSolution = new GapSolution(this.instance);\n    currSolution.initialize(this.random);\n    currSolution.computeObjective(capacityViolationPenalty);\n    this.bestSolution = currSolution;\n    this.perfRecords.add(new PerfRecord&lt;&gt;(0,\n      currSolution.getObjective(),\n      bestSolution.getObjective()));\n\n    int numTasks = this.instance.getNumTasks();\n    int numAgents = this.instance.getNumAgents();\n\n    // main workflow\n    int iter = 0;\n    int iterNoImprove = 0;\n    while (true) {\n      System.out.println(\"iter: \" + iter + \", best obj: \" + bestSolution.getObjective());\n      // create neighboring solutions\n      List&lt;GapSolutionNeighbor&gt; neighbors = new ArrayList&lt;&gt;(neighSize);\n      for (int i = 0; i &lt; neighSize; i++) {\n        // create a copy of current solution\n        GapSolution newSolution = new GapSolution(currSolution);\n\n        // mutate one task assignment\n        int randTaskIdx = this.random.nextInt(numTasks);\n        int currAgentIdx = newSolution.getAssignedAgent(randTaskIdx);\n        int newAgentIdx = this.random.nextInt(numAgents);\n        while (newAgentIdx == currAgentIdx) {\n          newAgentIdx = this.random.nextInt(numAgents);\n        }\n        newSolution.setAssignedAgent(randTaskIdx, newAgentIdx);\n\n        // compute objective value after mutation\n        newSolution.computeObjective(capacityViolationPenalty);\n\n        GapSolutionNeighbor neighbor = GapSolutionNeighbor.builder()\n          .newSolution(newSolution)\n          .mutatedTaskIdx(randTaskIdx)\n          .newAgentIdx(newAgentIdx)\n          .build();\n        neighbors.add(neighbor);\n      }\n\n      // sort neighboring solutions\n      neighbors.sort(Comparator.comparingInt(neighbor -&gt; neighbor.getNewSolution().getObjective()));\n\n      boolean currSolutionUpdated = false;\n      boolean bestSolutionUpdated = false;\n      // check tabu criteria\n      for (GapSolutionNeighbor neighbor : neighbors) {\n        GapSolution newSolution = neighbor.getNewSolution();\n        int mutatedTaskIdx = neighbor.getMutatedTaskIdx();\n        int newAgentIdx = neighbor.getNewAgentIdx();\n\n        if (this.tabuTable[mutatedTaskIdx][newAgentIdx] &lt; iter) {\n          // this move is not tabooed, proceed\n          currSolution = newSolution;\n          currSolutionUpdated = true;\n          this.tabuTable[mutatedTaskIdx][newAgentIdx] = iter + tabuLength;\n\n          if (currSolution.getObjective() &lt; this.bestSolution.getObjective()) {\n            this.bestSolution = currSolution;\n            bestSolutionUpdated = true;\n            break;\n          }\n        } else {\n          // check aspiration criterion\n          if (newSolution.getObjective() &lt; bestSolution.getObjective()) {\n            currSolution = newSolution;\n            bestSolution = currSolution;\n            currSolutionUpdated = true;\n            bestSolutionUpdated = true;\n            this.tabuTable[mutatedTaskIdx][newAgentIdx] = iter + tabuLength;\n            break;\n          }\n        }\n      }\n\n      // in case no move is possible, choose the best neighbor\n      if (!currSolutionUpdated) {\n        GapSolutionNeighbor neighbor = neighbors.getFirst();\n        currSolution = neighbor.getNewSolution();\n        this.tabuTable[neighbor.getMutatedTaskIdx()][neighbor.getNewAgentIdx()] = iter + tabuLength;\n      }\n\n      iter++;\n      this.perfRecords.add(new PerfRecord&lt;&gt;(iter,\n        currSolution.getObjective(),\n        bestSolution.getObjective()));\n\n      // check stopping criteria\n      iterNoImprove = bestSolutionUpdated ? 0 : iterNoImprove + 1;\n      if (iter &gt;= maxIter || iterNoImprove &gt;= maxIterNoImprove) {\n        break;\n      }\n    }\n  }\n\n  public void savePerfRecords(String filename) {\n    PerfRecordsWriter.write(filename, perfRecords);\n  }\n\n  public static void main(String[] args) {\n    String filename = \"/Users/klian/dev/metaheuristics-java-code/src/main/resources/data/gap/gap1.txt\";\n    String outputFilename = \"/Users/klian/dev/books/metaheuristics-java/data/gap/perf_records.txt\";\n    List&lt;GapInstance&gt; instances = GapInstanceReader.read(filename);\n\n    GapInstance instance = instances.get(1);\n    GapTabuSearch tabuSearch = new GapTabuSearch(instance);\n    tabuSearch.solve();\n    tabuSearch.savePerfRecords(outputFilename);\n  }\n}\n\n\n\n8.2.3 Performance on benchmarking instances\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv(\"/Users/klian/dev/books/metaheuristics-java/data/gap/perf_records.csv\", names=['iteration', 'curr_obj', 'best_obj'])\n\n\ndf\n\n\n\n\n\n\n\n\n\niteration\ncurr_obj\nbest_obj\n\n\n\n\n0\n0\n79294\n79294\n\n\n1\n1\n56291\n56291\n\n\n2\n2\n43294\n43294\n\n\n3\n3\n32300\n32300\n\n\n4\n4\n29306\n29306\n\n\n...\n...\n...\n...\n\n\n554\n554\n7294\n273\n\n\n555\n555\n1291\n273\n\n\n556\n556\n3297\n273\n\n\n557\n557\n1291\n273\n\n\n558\n558\n6288\n273\n\n\n\n\n559 rows × 3 columns\n\n\n\n\n\nfig, ax = plt.subplots(1, 1, figsize=(12, 4))\nax.plot(df['iteration'], df['curr_obj'], 'g--', label=\"current objective\")\nax.plot(df['iteration'], df['best_obj'], 'r--', label=\"best objective\")\nax.legend()\n\nax.set_xlim([0, 100])\nax.set_ylim([0, 80000])",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tabu Search for GAP</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "9  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Summary</span>"
    ]
  }
]
[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Metaheuristics in Java",
    "section": "",
    "text": "Preface\nMetaheuristics, despite the skepticism they sometimes draw from the academic community (see Sörensen 2015), have proven their value across various industrial sectors by addressing complex optimization challenges. The pragmatic nature of these algorithms makes them especially appealing in real-world scenarios where theoretical purity must often yield to practical efficacy.\nThis book is designed for practitioners, students, and anyone curious about metaheuristics, providing a hands-on introduction to these algorithms using Java. Rather than focusing on the optimal or most sophisticated implementation of each algorithm, this book opts for straightforward, sometimes naive, implementations. The primary goal is to illustrate how these algorithms function and how they can be applied, making this a highly accessible resource for readers who are new to the field or looking to understand the basic mechanics of these powerful tools.\nEach chapter dives into a different metaheuristic algorithm, such as Genetic Algorithms, Simulated Annealing, and Tabu Search. By implementing these in Java—a language renowned for its versatility and widespread use—we demonstrate the core concepts and workflows of these algorithms in a clear and approachable manner. Through simple code examples, readers will see how metaheuristics can be employed to tackle optimization problems in logistics, scheduling, network design, and beyond.\nThe emphasis of this book is on learning by doing. By providing simple implementations, we enable readers to grasp the essential ideas and encourage them to experiment and adapt these algorithms to their specific needs. This approach demystifies the sometimes daunting aspect of metaheuristics and showcases their practical utility without getting bogged down in complex coding techniques or advanced theoretical discussions.\nBy the conclusion of this book, you will have a solid understanding of various metaheuristic algorithms and be prepared to apply them to real-world problems. Whether your interest lies in enhancing your academic knowledge, improving your professional toolkit, or simply exploring new methods for problem-solving, this book will serve as a valuable starting point for working with metaheuristics in a meaningful and impactful way.\nLet’s embark on this journey of discovery together, learning how straightforward implementations of metaheuristics can offer powerful solutions to the complex challenges faced in diverse industries today.\n\n\n\n\nSörensen, Kenneth. 2015. “Metaheuristics—the Metaphor Exposed.” International Transactions in Operational Research 22 (1): 3–18. https://doi.org/10.1111/itor.12001.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Algorithms\nThe metaheuristic algorithms to be included in this book are:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#algorithms",
    "href": "intro.html#algorithms",
    "title": "1  Introduction",
    "section": "",
    "text": "GA: Genetic Algorithm\nSA: Simulated Annealing\nTS: Tabu Search\nLNS: Large Neighborhood Search\nPSO: Particle Swarm Optimization\nACO: Ant Colony Optimization",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#problems",
    "href": "intro.html#problems",
    "title": "1  Introduction",
    "section": "1.2 Problems",
    "text": "1.2 Problems\nWe will use the aforementioned metaheuristic algorithms to solve various optimization problems:\n\nGAP: Generalized Assignment Problem\nVRP: Vehicle Routing Problem",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#overview",
    "href": "intro.html#overview",
    "title": "1  Introduction",
    "section": "1.3 Overview",
    "text": "1.3 Overview\nNot every algorithm will be applied to a problem; the checkmark in the table below signifies which algorithms are used to address specific problems.\n\n\n\n\n\n\n\n\n\n\nGA\nSA\nTS\n\n\n\n\nGAP\n✓\n✓\n✓\n\n\nVRP",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "workflow-ga.html",
    "href": "workflow-ga.html",
    "title": "2  Genetic Algorithm Workflow",
    "section": "",
    "text": "2.1 Algorithmic Workflow\nThe workflow of a genetic algorithm can be broken down into the following steps:\nFigure 2.1 shows the workflow of the genetic algorithm.\nflowchart TD\n    A[Start] --&gt; B[Initialize Population]\n    B --&gt; C{Check Stopping Criteria}\n    C --&gt;|Stopping Criteria Not Met| D[Select Parents]\n    D --&gt; E[Perform Crossover]\n    E --&gt; F[Apply Mutation]\n    F --&gt; G[Form New Population]\n    G --&gt; C\n    C --&gt;|Stopping Criteria Met| H[End]\n\n\n\n\nFigure 2.1: Genetic algorithm workflow",
    "crumbs": [
      "Algorithm Workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Genetic Algorithm Workflow</span>"
    ]
  },
  {
    "objectID": "workflow-ga.html#algorithmic-workflow",
    "href": "workflow-ga.html#algorithmic-workflow",
    "title": "2  Genetic Algorithm Workflow",
    "section": "",
    "text": "Initialization:\n\n\nGenerate an initial population: This population consists of a number of individuals, and each individual (also known as a chromosome) represents a potential solution to the problem. The individuals are usually represented as strings of bits, characters, or numbers.\n\n\nEvaluation:\n\n\nCalculate fitness: Each individual in the population is evaluated based on a fitness function. This function determines how well an individual solves the problem at hand. The fitness score is crucial as it determines the likelihood that an individual will be selected for reproduction.\n\n\nSelection:\n\n\nSelect parents: Individuals are selected to contribute to the next generation. The selection is often based on their fitness scores—the higher the fitness, the higher the probability of selection. Common selection methods include roulette wheel selection, tournament selection, and rank selection.\n\n\nCrossover (Recombination):\n\n\nGenerate offspring: Selected individuals (parents) are paired and recombined to produce offspring. Crossover is the genetic algorithm’s primary mechanism for generating new candidate solutions. One common method is the single-point crossover, where a point is chosen on the parent chromosomes, and the genetic material is swapped over this point to create new offspring.\n\n\nMutation:\n\n\nIntroduce mutations: With a small probability, mutations are introduced to the offspring. Mutation involves altering one or more gene values in an individual’s chromosome. It serves to maintain genetic diversity within the population and helps to avoid local minima by introducing novel solutions.\n\n\nReplacement:\n\n\nUpdate the population: The offspring are then used to replace some or all of the older generation of individuals. This can be done in various ways, such as replacing the least fit individuals, replacing random individuals, or using a strategy like elitism, where the best individuals are always preserved.\n\n\nTermination:\n\n\nCheck termination conditions: The algorithm repeats the cycle of evaluation, selection, crossover, and mutation until a termination condition is met. Common termination conditions include reaching a maximum number of generations, achieving a sufficient fitness level, or having the population’s fitness level plateau across several generations.",
    "crumbs": [
      "Algorithm Workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Genetic Algorithm Workflow</span>"
    ]
  },
  {
    "objectID": "workflow-sa.html",
    "href": "workflow-sa.html",
    "title": "3  Simulated Annealing Workflow",
    "section": "",
    "text": "3.1 Algorithm Workflow\nThe workflow for the Simulated Annealing algorithm is typically as follows:\nFigure 3.1 shows the workflow of simulated annealing.\nflowchart TD\n    A[Start] --&gt; B[Initialize Solution]\n    B --&gt; C[Set Initial Temperature]\n    C --&gt; D[Begin Optimization Loop]\n\n    D --&gt; E[Select Neighbor]\n    E --&gt; G[Accept New Solution?]\n    G --&gt;|Yes| H[Update Current Solution]\n    H --&gt; I[Reduce Temperature]\n    I --&gt; J{Check Termination Criteria}\n    J --&gt;|No| D\n    J --&gt;|Yes| K[End]\n\n    G --&gt;|No| I\n\n\n\n\nFigure 3.1: Simulated annealing workflow",
    "crumbs": [
      "Algorithm Workflow",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Simulated Annealing Workflow</span>"
    ]
  },
  {
    "objectID": "workflow-sa.html#algorithm-workflow",
    "href": "workflow-sa.html#algorithm-workflow",
    "title": "3  Simulated Annealing Workflow",
    "section": "",
    "text": "Initialization:\n\n\nStart with an initial solution (often generated at random).\nSet an initial temperature that is high enough to allow for exploration of the entire search space.\nDefine the cooling schedule, which is the process of lowering the temperature gradually as the algorithm proceeds.\n\n\nIterative Optimization:\n\n\nSelect a neighbor: At each step of the algorithm, generate a “neighboring” solution. This is typically a small random variation of the current solution.\nCalculate the change in energy (cost difference): Determine the difference in the objective function values between the current solution and the generated neighbor.\nDecide to accept the new solution: This decision is made using the Metropolis criterion:\n\nIf the new solution improves the objective function (i.e., it has lower energy in minimization problems), it is always accepted.\nIf the new solution does not improve the objective function, it may still be accepted with a probability that depends on the difference in the objective function values and the current temperature. The probability is calculated using the formula \\(P = e^{-\\Delta e/t}\\) where \\(\\Delta e\\) is the change in energy, and \\(T\\) is the current temperature.\n\n\n\nCooling:\n\n\nReduce the temperature according to the cooling schedule. This reduction in temperature reduces the probability of accepting worse solutions, thus allowing the algorithm to focus more on exploitation rather than exploration as it converges.\n\n\nTermination:\n\n\nRepeat the iterative process of exploring neighboring solutions and adjusting temperatures until a stopping criterion is met, such as reaching a minimum temperature, a maximum number of iterations, or a satisfactory solution stability.",
    "crumbs": [
      "Algorithm Workflow",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Simulated Annealing Workflow</span>"
    ]
  },
  {
    "objectID": "workflow-ts.html",
    "href": "workflow-ts.html",
    "title": "4  Tabu Search Workflow",
    "section": "",
    "text": "4.1 Algorithm Workflow and Key Steps\nTabu Search is a metaheuristic algorithm used for solving combinatorial optimization problems. It was proposed by Fred Glover in 1986. The primary idea behind Tabu Search is to iteratively explore the solution space in search of the optimal or near-optimal solution by intelligently navigating through the space of feasible solutions.\nHere’s a high-level explanation of how the Tabu Search algorithm works:\nTabu Search is known for its ability to efficiently explore complex solution spaces, often outperforming other traditional optimization techniques. It’s widely used in various domains, including operations research, scheduling, logistics, and engineering design, among others.\nFigure 4.1 shows the workflow of Tabu Search. After creating and evaluating the initial solution, Tabu search requires an iterative process of neighborhood solution generation, tabu/aspiration criteria checking and next solution selection to approximate the optimal solutions.\ngraph TD;\n    A[Initialization] --&gt; B[Generate Initial Solution];\n    B --&gt; C[Evaluate Solution];\n    C --&gt; D[Generate Neighboring Solutions];\n    D --&gt; E[Evaluate Neighboring Solutions];\n    E --&gt; F[Tabu Criteria];\n    F --&gt; G[Aspiration Criteria];\n    G --&gt; H[Select Next Solution];\n    H --&gt; I[Termination Condition];\n    I --&gt; J[Output];\n    J --&gt; D;\n\n\n\n\nFigure 4.1: Tabu search algorithm workflow",
    "crumbs": [
      "Algorithm Workflow",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tabu Search Workflow</span>"
    ]
  },
  {
    "objectID": "workflow-ts.html#algorithm-workflow-and-key-steps",
    "href": "workflow-ts.html#algorithm-workflow-and-key-steps",
    "title": "4  Tabu Search Workflow",
    "section": "",
    "text": "Initialization:\n\nStart with an initial solution, which can be generated randomly or through some heuristic method.\nInitialize a Tabu list to keep track of previously visited solutions.\n\nGenerating Neighboring Solutions:\n\nGenerate neighboring solutions by making small modifications to the current solution. These modifications could involve swapping, inserting, deleting, or otherwise altering elements of the current solution.\nNeighboring solutions are usually generated based on some predefined neighborhood structure specific to the problem being solved.\n\nEvaluating Neighboring Solutions:\n\nEvaluate each neighboring solution using an objective function that measures the quality of the solution.\nThe objective function reflects the optimization criteria of the problem, such as minimizing cost, maximizing profit, etc.\n\nTabu Criteria:\n\nIntroduce Tabu criteria to determine which neighboring solutions are permissible for exploration.\nThe Tabu list contains information about recent moves or solutions that are prohibited from being selected in the current iteration. This prevents the algorithm from revisiting solutions that have already been explored or to avoid getting stuck in local optima.\n\nAspiration Criteria:\n\nIn some cases, solutions in the Tabu list may be revisited if they lead to a significant improvement over the current best solution. This is governed by aspiration criteria, which allow certain Tabu moves under specific circumstances.\n\nUpdating Tabu List:\n\nUpdate the Tabu list to reflect the recent moves or solutions that have been explored. This ensures that the algorithm avoids cycling through the same solutions repeatedly.\n\nSelecting Next Solution:\n\nChoose the next solution to explore based on a combination of factors, including the quality of the solution, Tabu status, aspiration criteria, and possibly randomization to encourage exploration.\n\nTermination Condition:\n\nRepeat the above steps iteratively until a termination condition is met. This condition could be a maximum number of iterations, reaching a predefined solution quality threshold, or running out of computational resources.\n\nOutput:\n\nReturn the best solution found during the search process.",
    "crumbs": [
      "Algorithm Workflow",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tabu Search Workflow</span>"
    ]
  },
  {
    "objectID": "workflow-ts.html#key-considerations",
    "href": "workflow-ts.html#key-considerations",
    "title": "4  Tabu Search Workflow",
    "section": "4.2 Key Considerations",
    "text": "4.2 Key Considerations\nWhen implementing the Tabu Search algorithm to solve optimization problems, there are several important aspects to consider to ensure its effectiveness and efficiency:\n\nProblem Representation: Choose an appropriate representation of solutions for the optimization problem at hand. The representation should allow easy manipulation and evaluation of solutions.\nObjective Function: Define a clear and appropriate objective function that quantifies the quality of solutions based on the problem requirements. This function guides the search for optimal or near-optimal solutions.\nNeighborhood Structure: Design a neighborhood structure that defines how neighboring solutions are generated from the current solution. This structure greatly influences the search process and should allow for efficient exploration of the solution space.\nTabu List Management: Implement an efficient mechanism to manage the Tabu list, which keeps track of recent moves or solutions that are prohibited from being revisited. Consider factors such as Tabu tenure (how long a move remains prohibited), size of the Tabu list, and strategies for updating and clearing the list.\nAspiration Criteria: Define aspiration criteria to determine when to override Tabu restrictions based on certain conditions, such as significant improvements in solution quality.\nDiversification Strategies: Incorporate diversification strategies to ensure exploration of diverse regions of the solution space. This helps prevent the algorithm from getting stuck in local optima.\nIntensification Strategies: Implement intensification strategies to focus the search on promising regions of the solution space, especially as the algorithm progresses. This may involve prioritizing certain types of moves or solutions.\nTermination Criteria: Define appropriate termination criteria to determine when to stop the search process. This could be based on reaching a maximum number of iterations, a specified solution quality threshold, or other factors.\nParameter Tuning: Experiment with different parameter settings, such as Tabu tenure, neighborhood size, and aspiration criteria thresholds, to find the most effective configurations for the specific problem being solved.\nEfficient Data Structures and Algorithms: Use efficient data structures and algorithms for solution representation, neighborhood generation, and Tabu list management to optimize the computational performance of the algorithm.\nValidation and Testing: Validate the implementation by testing it on a variety of problem instances with known optimal solutions, if available. This helps verify the correctness and effectiveness of the algorithm.\n\nBy paying attention to these aspects when implementing the Tabu Search algorithm, we can enhance its performance and increase the likelihood of finding high-quality solutions to optimization problems.\nIn the remaining chapters of this book, we will apply Tabu Search to solve various optimization problems to demonstrate some of aforementioned points.",
    "crumbs": [
      "Algorithm Workflow",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tabu Search Workflow</span>"
    ]
  },
  {
    "objectID": "gap-intro.html",
    "href": "gap-intro.html",
    "title": "5  Generalized Assignment Problem",
    "section": "",
    "text": "5.1 Problem Statement\nFormally, the Generalized Assignment Problem can be defined as follows:\nGiven:\nThe goal is to find an assignment of tasks to agents that minimizes the total cost or maximizes the total profit, while ensuring that each task is assigned to one or more agents, and the total resource requirement of each agent does not exceed its capacity.\nMathematically, the GAP can be formulated as an integer linear programming problem. One possible formulation is as follows:\n\\[\n\\begin{aligned}\n\\text{min.} &\\quad \\sum_{i=1}^{n} \\sum_{j=1}^{m} c_{ij} x_{ij} \\label{gap-obj}\\\\\n\\text{s.t.} &\\quad \\sum_{j=1}^{m} x_{ij} = 1, \\ \\forall i = 1, 2, ..., n \\label{gap-cons1}\\\\\n&\\quad \\sum_{i=1}^{n} r_{ij} x_{ij} \\leq b_j, \\  \\forall j = 1, 2, ..., m \\label{gap-cons2}\\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall i = 1, 2, ..., n, j = 1, 2, ..., m \\label{gap-cons3}\n\\end{aligned}\n\\]\nwhere \\(x_{ij}\\) is a binary decision variable that equals 1 if task \\(i\\) is assigned to agent \\(j\\), and 0 otherwise.\nThe first set of constraints ensures that each task is assigned to exactly one agent, and the second set of constraints ensures that the total resource requirement of each agent does not exceed its capacity.\nSolving the GAP can be computationally challenging, especially for large instances, as it is a generalization of the classic assignment problem, which is known to be polynomial-time solvable. Various algorithms and heuristics, such as branch and bound, dynamic programming, and approximation algorithms, can be employed to find feasible or optimal solutions to the GAP.",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "gap-intro.html#problem-statement",
    "href": "gap-intro.html#problem-statement",
    "title": "5  Generalized Assignment Problem",
    "section": "",
    "text": "A set of tasks, \\(T = \\{1, 2, ..., n\\}\\)\nA set of agents, \\(A = \\{1, 2, ..., m\\}\\)\nFor each task \\(i\\) and agent \\(j\\), a cost or profit \\(c_{ij}\\) associated with assigning task \\(i\\) to agent \\(j\\)\nFor each task \\(i\\) and agent \\(j\\), a resource requirement \\(r_{ij}\\) specifying the amount of resource needed from agent \\(j\\) to complete task \\(i\\)\nFor each agent \\(j\\), a capacity \\(b_j\\) specifying the maximum amount of resource that agent \\(j\\) can contribute",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "gap-intro.html#benchmarking-problems",
    "href": "gap-intro.html#benchmarking-problems",
    "title": "5  Generalized Assignment Problem",
    "section": "5.2 Benchmarking Problems",
    "text": "5.2 Benchmarking Problems\nThere are benchmarking problems available here. Listing 5.1 shows one of the instance file with five instances in it.\n\n\n\nListing 5.1: GAP instance\n\n\n\n\ngap1.txt\n\n 5\n 5 15\n 17 21 22 18 24 15 20 18 19 18 16 22 24 24 16\n 23 16 21 16 17 16 19 25 18 21 17 15 25 17 24\n 16 20 16 25 24 16 17 19 19 18 20 16 17 21 24\n 19 19 22 22 20 16 19 17 21 19 25 23 25 25 25\n 18 19 15 15 21 25 16 16 23 15 22 17 19 22 24\n 8 15 14 23 8 16 8 25 9 17 25 15 10 8 24\n 15 7 23 22 11 11 12 10 17 16 7 16 10 18 22\n 21 20 6 22 24 10 24 9 21 14 11 14 11 19 16\n 20 11 8 14 9 5 6 19 19 7 6 6 13 9 18\n 8 13 13 13 10 20 25 16 16 17 10 10 5 12 23\n 36 34 38 27 33\n 5 15\n 19 23 24 20 20 25 16 21 24 15 17 17 20 20 20\n 25 24 16 21 19 17 17 19 23 21 21 23 20 15 16\n 16 21 25 22 24 24 16 17 15 18 15 17 18 24 18\n 25 24 18 19 15 18 20 22 23 18 16 19 17 15 22\n 25 19 21 22 20 15 20 19 18 18 17 23 17 25 25\n 16 12 8 20 18 10 12 8 14 23 19 14 15 15 24\n 16 18 19 22 13 20 9 7 25 10 20 13 11 15 16\n 6 20 20 5 14 12 6 15 22 18 13 23 23 18 25\n 18 23 25 17 25 13 23 23 13 20 20 23 17 19 24\n 12 17 15 25 22 5 24 19 12 25 23 21 23 19 18\n 36 37 38 48 44\n 5 15\n 22 21 16 17 21 15 17 22 22 25 18 20 24 15 22\n 23 24 19 15 16 21 15 25 16 21 20 19 16 23 20\n 21 20 21 25 21 20 21 19 17 16 25 19 15 15 15\n 17 21 25 25 23 22 20 19 20 25 15 20 21 25 23\n 15 25 23 19 17 17 25 24 24 17 24 19 18 19 16\n 23 10 15 13 17 10 13 6 9 21 20 7 9 25 8\n 17 13 8 23 11 18 7 22 13 5 24 24 15 10 22\n 22 17 22 23 20 11 17 25 23 9 22 20 15 9 25\n 5 19 25 16 15 10 18 9 11 20 7 21 15 8 25\n 22 9 10 23 19 21 17 15 15 17 25 19 10 9 21\n 32 37 44 35 40\n 5 15\n 15 25 20 18 19 21 18 22 24 15 25 17 17 15 22\n 20 18 25 25 16 24 22 24 17 18 23 25 21 25 24\n 25 19 18 18 23 18 15 22 23 16 25 22 22 15 16\n 19 19 23 17 19 19 22 19 23 22 24 22 25 19 16\n 25 24 17 19 25 19 23 19 25 15 19 21 18 19 22\n 20 20 18 9 18 5 16 18 13 24 21 23 15 19 9\n 5 12 18 8 22 19 19 11 7 19 20 17 21 25 5\n 18 8 8 9 20 20 23 13 15 12 6 12 25 25 23\n 17 19 24 9 16 22 10 17 12 17 15 21 16 18 6\n 14 6 20 6 21 5 11 23 20 21 20 18 13 13 21\n 39 36 37 38 37\n 5 15\n 25 25 18 24 20 19 25 24 23 15 18 18 25 15 22\n 25 18 17 22 21 23 20 23 16 19 15 18 16 23 16\n 18 16 19 15 15 18 15 20 19 24 22 20 25 16 21\n 18 21 16 18 17 24 18 23 22 16 17 22 22 18 16\n 17 18 15 21 23 21 24 23 20 22 19 15 22 22 25\n 16 20 9 22 17 19 20 22 20 13 6 20 23 19 7\n 12 22 18 18 6 13 17 17 17 14 20 12 17 14 22\n 5 19 19 14 24 16 7 8 9 22 13 23 24 15 20\n 20 8 6 9 5 17 23 18 14 12 14 17 15 23 21\n 6 6 24 24 8 7 5 25 21 18 12 20 20 7 12\n 40 38 38 35 34\n\n\n\n\nListing 5.2 contains the Java class to hold the content of an instance. The class contains a couple of key information:\n\nnumTasks: the total number of tasks in the instance.\nnumAgents: the total number of agents available to process the tasks.\ncosts: a two-dimensional array with costs[i][j] representing the cost of assigning task j to agent i.\nresources: a two-dimensional array with resources[i][j] representing the resource requirement of assigning task j to agent i.\ncapacities: a one-dimensional array with capacities[i] representing the capacity of agent i.\n\n\n\n\nListing 5.2: GAP instance class\n\n\n\n\nGapInstance.java\n\npackage com.voyager.opt.metaheuristics.gap;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\n\n@Data\n@Builder\n@AllArgsConstructor\npublic class GapInstance {\n  /**\n   * total number of tasks\n   */\n  private int numTasks;\n  /**\n   * total number of agents\n   */\n  private int numAgents;\n  /**\n   * costs of assigning tasks to agents\n   * dimension: numAgents * numTasks\n   */\n  private int[][] costs;\n  /**\n   * resource consumption of assigning tasks to agents\n   * dimension: numAgents * numTasks\n   */\n  private int[][] resources;\n  /**\n   * agent capacities\n   * dimension: numAgents\n   */\n  private int[] capacities;\n}\n\n\n\n\nListing 5.3 gives a Java class that reads the instance file and outputs a list of GapInstance objects.\n\n\n\nListing 5.3: GAP instance reader class\n\n\n\n\nGapInstanceReader.java\n\npackage com.voyager.opt.metaheuristics.gap;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic final class GapInstanceReader {\n\n  /**\n   * read instance filePath and return all the contained instances\n   * @param filePath instance filename\n   * @return list of instances\n   */\n  public static List&lt;GapInstance&gt; read(String filePath) {\n    List&lt;GapInstance&gt; instances = new ArrayList&lt;&gt;();\n    try {\n      BufferedReader reader = new BufferedReader(new FileReader(filePath));\n      int numInstances = Integer.parseInt(reader.readLine().trim());\n\n      for (int p = 0; p &lt; numInstances; p++) {\n        String[] mn = reader.readLine().trim().split(\" \");\n        int numAgents = Integer.parseInt(mn[0]); // Number of agents\n        int numTasks = Integer.parseInt(mn[1]); // Number of tasks\n\n        // Reading costs\n        int[][] costs = new int[numAgents][numTasks];\n        for (int i = 0; i &lt; numAgents; i++) {\n          String[] costsLine = reader.readLine().trim().split(\" \");\n          for (int j = 0; j &lt; numTasks; j++) {\n            costs[i][j] = Integer.parseInt(costsLine[j]);\n          }\n        }\n\n        // Reading resources\n        int[][] resources = new int[numAgents][numTasks];\n        for (int i = 0; i &lt; numAgents; i++) {\n          String[] resourcesLine = reader.readLine().trim().split(\" \");\n          for (int j = 0; j &lt; numTasks; j++) {\n            resources[i][j] = Integer.parseInt(resourcesLine[j]);\n          }\n        }\n\n        // Reading resource capacities\n        int[] agentCapacities = new int[numAgents];\n        String[] capacitiesLine = reader.readLine().trim().split(\" \");\n        for (int i = 0; i &lt; numAgents; i++) {\n          agentCapacities[i] = Integer.parseInt(capacitiesLine[i]);\n        }\n\n        GapInstance instance = GapInstance.builder()\n          .numTasks(numTasks)\n          .numAgents(numAgents)\n          .costs(costs)\n          .resources(resources)\n          .capacities(agentCapacities)\n          .build();\n        instances.add(instance);\n      }\n      reader.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return instances;\n  }\n}",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "gap-ga.html",
    "href": "gap-ga.html",
    "title": "6  Genetic Algorithm for GAP",
    "section": "",
    "text": "6.1 Algorithm Design",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Genetic Algorithm for GAP</span>"
    ]
  },
  {
    "objectID": "gap-ga.html#implementation-details",
    "href": "gap-ga.html#implementation-details",
    "title": "6  Genetic Algorithm for GAP",
    "section": "6.2 Implementation Details",
    "text": "6.2 Implementation Details\n\n\n\nListing 6.1: The solution class\n\n\n\n\nGapSolution.java\n\npackage com.voyager.opt.metaheuristics.gap;\n\nimport lombok.Getter;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.stream.IntStream;\n\n@Getter\npublic final class GapSolution {\n  /**\n   * reference to the instance to be solved\n   */\n  private final GapInstance instance;\n  /**\n   * dimension: 1 * numTasks\n   * assigned agent index for each task\n   */\n  private final int[] agentAssignments;\n  /**\n   * dimension: 1 * numAgents\n   * consumed capacity of each agent\n   */\n  private final int[] consumedCapacities;\n  /**\n   * total objective value\n   */\n  private int objective;\n  /**\n   * assignment cost, without penalties\n   */\n  private int assignmentCost;\n  /**\n   * capacity violation penalties of all agents\n   */\n  private int capacityViolationPenalty;\n\n  public GapSolution(GapInstance instance) {\n    this.instance = instance;\n    this.agentAssignments = new int[this.instance.getNumTasks()];\n    this.consumedCapacities = new int[this.instance.getNumAgents()];\n    Arrays.fill(this.agentAssignments, 0);\n    Arrays.fill(consumedCapacities, 0);\n    this.objective = 0;\n    this.assignmentCost = 0;\n    this.capacityViolationPenalty = 0;\n  }\n\n  /**\n   * copy constructor\n   * @param other the other solution to copy from\n   */\n  public GapSolution(GapSolution other) {\n    this.instance = other.instance;\n    this.agentAssignments = new int[this.instance.getNumTasks()];\n    System.arraycopy(other.agentAssignments, 0,\n      this.agentAssignments, 0,\n      this.instance.getNumTasks());\n    this.consumedCapacities = new int[this.instance.getNumAgents()];\n    System.arraycopy(other.consumedCapacities, 0,\n      this.consumedCapacities, 0,\n      this.instance.getNumAgents());\n    this.objective = other.objective;\n    this.assignmentCost = other.assignmentCost;\n    this.capacityViolationPenalty = other.capacityViolationPenalty;\n  }\n\n  /**\n   * randomly assign tasks to agents\n   * @param random random number generator\n   */\n  public void initialize(Random random) {\n    int[][] resources = this.instance.getResources();\n    for (int i = 0; i &lt; instance.getNumTasks(); i++) {\n      int agentIdx = random.nextInt(instance.getNumAgents());\n      this.agentAssignments[i] = agentIdx;\n      this.consumedCapacities[agentIdx] += resources[agentIdx][i];\n    }\n  }\n\n  /**\n   * compute objective values\n   * @param capacityViolationPenalty penalty factor\n   */\n  public void computeObjective(int capacityViolationPenalty) {\n    // compute assignment costs\n    this.assignmentCost = IntStream.range(0, instance.getNumTasks())\n      .map(taskIdx -&gt; instance.getCosts()[agentAssignments[taskIdx]][taskIdx])\n      .sum();\n\n    // compute capacity violation costs\n    this.capacityViolationPenalty = IntStream.range(0, instance.getNumAgents())\n      .map(agentIdx -&gt; capacityViolationPenalty *\n        Math.max(0, this.consumedCapacities[agentIdx] - instance.getCapacities()[agentIdx]))\n      .sum();\n\n    this.objective = this.assignmentCost + this.capacityViolationPenalty;\n  }\n\n  public int getAssignedAgent(int taskIdx) {\n    return this.agentAssignments[taskIdx];\n  }\n\n  /**\n   * assign agent to task\n   * @param taskIdx the task to be assigned\n   * @param agentIdx the agent index\n   */\n  public void setAssignedAgent(int taskIdx, int agentIdx) {\n    int currAgentIdx = this.agentAssignments[taskIdx];\n    this.agentAssignments[taskIdx] = agentIdx;\n    this.consumedCapacities[currAgentIdx] -= instance.getResources()[currAgentIdx][taskIdx];\n    this.consumedCapacities[agentIdx] += instance.getResources()[agentIdx][taskIdx];\n  }\n}\n\n\n\n\n\n\n\nListing 6.2: Genetic algorithm implementation\n\n\n\n\nGapGeneticAlgo.java\n\npackage com.voyager.opt.metaheuristics.gap.ga;\n\nimport com.voyager.opt.metaheuristics.gap.GapInstance;\nimport com.voyager.opt.metaheuristics.gap.GapInstanceReader;\nimport com.voyager.opt.metaheuristics.gap.GapSolution;\nimport com.voyager.opt.metaheuristics.utils.PerfRecord;\nimport com.voyager.opt.metaheuristics.utils.PerfRecordsWriter;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Random;\n\n@Getter\n@Setter\npublic class GapGeneticAlgo {\n  private static final int MAX_GENERATIONS = 1000;\n  private static final int POPULATION_SIZE = 100;\n  private static final double MUTATION_RATE = 0.2;\n  private static final int TOURNAMENT_SIZE = 5;\n\n  private final GapInstance instance;\n  /**\n   * random number generator\n   */\n  private final Random random;\n  /**\n   * best solution\n   */\n  private GapSolution bestSolution;\n  /**\n   * performance records\n   */\n  private final List&lt;PerfRecord&lt;Integer&gt;&gt; perfRecords;\n\n  private final int capacityViolationPenalty = 1000;\n\n  public GapGeneticAlgo(GapInstance instance) {\n    this.instance = instance;\n    this.random = new Random(42);\n    this.perfRecords = new ArrayList&lt;&gt;();\n  }\n\n  /**\n   * main workflow\n   */\n  public void solve() {\n    // Initialize population\n    List&lt;GapSolution&gt; population = initializePopulation();\n\n    // Evolution loop\n    for (int generation = 0; generation &lt; MAX_GENERATIONS; generation++) {\n      // collect and save performance metrics\n      PerfRecord&lt;Integer&gt; perf = collectPerformanceMetrics(population);\n      perf.setIteration(generation);\n      perfRecords.add(perf);\n      System.out.println(perf.toCommaDelimitedString());\n\n      // Crossover\n      List&lt;GapSolution&gt; offspring = crossover(population);\n\n      // Mutation\n      mutate(offspring);\n\n      // Replace old population with new population\n      population.addAll(offspring);\n      population.sort(Comparator.comparingInt(GapSolution::getObjective));\n\n      List&lt;GapSolution&gt; nextGenPop = new ArrayList&lt;&gt;(POPULATION_SIZE);\n      for (int i = 0; i &lt; POPULATION_SIZE; i++) {\n        nextGenPop.add(population.get(i));\n      }\n      population = nextGenPop;\n    }\n\n    // Select the best solution from the final population\n    PerfRecord&lt;Integer&gt; perf = collectPerformanceMetrics(population);\n    perf.setIteration(MAX_GENERATIONS);\n    perfRecords.add(perf);\n  }\n\n  /**\n   * randomly create a population of solutions\n   * @return new solutions\n   */\n  private List&lt;GapSolution&gt; initializePopulation() {\n    List&lt;GapSolution&gt; population = new ArrayList&lt;&gt;(POPULATION_SIZE);\n    for (int i = 0; i &lt; POPULATION_SIZE; i++) {\n      GapSolution solution = new GapSolution(instance);\n      solution.initialize(random);\n      solution.computeObjective(capacityViolationPenalty);\n      population.add(solution);\n    }\n    return population;\n  }\n\n  /**\n   * identify the best solution from the given population and average objective value\n   * @param population input population\n   * @return performance record\n   */\n  private PerfRecord&lt;Integer&gt; collectPerformanceMetrics(List&lt;GapSolution&gt; population) {\n    GapSolution bestSol = population.stream()\n      .sorted(Comparator.comparingDouble(GapSolution::getObjective))\n      .toList().getFirst();\n    if (this.bestSolution == null || this.bestSolution.getObjective() &gt; bestSol.getObjective()) {\n      this.bestSolution = bestSol;\n    }\n\n    double avgObj = population.stream()\n      .mapToInt(GapSolution::getObjective)\n      .average()\n      .getAsDouble();\n    return new PerfRecord&lt;&gt;(0, (int) avgObj, bestSolution.getObjective());\n  }\n\n  /**\n   * select the best solution from multiple candidate solutions\n   *\n   * @param population input solution population\n   * @return best solution\n   */\n  private GapSolution selectParent(List&lt;GapSolution&gt; population) {\n    GapSolution champion = population.get(random.nextInt(POPULATION_SIZE));\n    for (int i = 0; i &lt; TOURNAMENT_SIZE - 1; i++) {\n      GapSolution challenger = population.get(random.nextInt(POPULATION_SIZE));\n      if (challenger.getObjective() &lt; champion.getObjective()) {\n        champion = challenger;\n      }\n    }\n    return champion;\n  }\n\n  /**\n   * crossover operator that generates a new solution population\n   *\n   * @param parents parent solutions\n   * @return child solutions\n   */\n  private List&lt;GapSolution&gt; crossover(List&lt;GapSolution&gt; parents) {\n    // Here, we can use different crossover techniques such as one-point crossover or uniform crossover\n    // For simplicity, let's use one-point crossover\n    List&lt;GapSolution&gt; offspring = new ArrayList&lt;&gt;(POPULATION_SIZE);\n    for (int i = 0; i &lt; POPULATION_SIZE; i++) {\n      GapSolution parent1 = selectParent(parents);\n      GapSolution parent2 = selectParent(parents);\n\n      int crossoverPoint = random.nextInt(instance.getNumTasks() - 1) + 1; // Ensure crossoverPoint is not 0\n\n      // Create offspring by swapping genes between parents\n      GapSolution offspring1 = new GapSolution(parent1);\n      GapSolution offspring2 = new GapSolution(parent2);\n\n      for (int j = crossoverPoint; j &lt; instance.getNumTasks(); j++) {\n        int temp = offspring1.getAssignedAgent(j);\n        offspring1.setAssignedAgent(j, offspring2.getAssignedAgent(j));\n        offspring2.setAssignedAgent(j, temp);\n      }\n\n      offspring1.computeObjective(capacityViolationPenalty);\n      offspring2.computeObjective(capacityViolationPenalty);\n\n      offspring.add(offspring1);\n      offspring.add(offspring2);\n    }\n\n    return offspring;\n  }\n\n  /**\n   * mutation introduces minor changes to the given solutions\n   *\n   * @param population solutions to perform mutations on\n   */\n  private void mutate(List&lt;GapSolution&gt; population) {\n    for (GapSolution solution : population) {\n      if (random.nextDouble() &lt; MUTATION_RATE) {\n        for (int taskIdx = 0; taskIdx &lt; instance.getNumTasks(); taskIdx++) {\n          if (random.nextDouble() &lt; MUTATION_RATE / 2.0) {\n            int newAgentIdx = random.nextInt(instance.getNumAgents());\n            solution.setAssignedAgent(taskIdx, newAgentIdx);\n          }\n        }\n        solution.computeObjective(capacityViolationPenalty);\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    File file = new File(\"src/main/resources/data/gap/gap1.txt\");\n    String filePath = file.getAbsolutePath();\n    String outputFilename = \"/Users/klian/dev/books/metaheuristics-java/data/gap/perf_records_ga.csv\";\n    List&lt;GapInstance&gt; instances = GapInstanceReader.read(filePath);\n\n    GapInstance instance = instances.get(4);\n    GapGeneticAlgo geneticAlgo = new GapGeneticAlgo(instance);\n    geneticAlgo.solve();\n\n    // save performance records\n    PerfRecordsWriter.write(outputFilename, geneticAlgo.getPerfRecords());\n  }\n}",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Genetic Algorithm for GAP</span>"
    ]
  },
  {
    "objectID": "gap-ga.html#performance-illustration",
    "href": "gap-ga.html#performance-illustration",
    "title": "6  Genetic Algorithm for GAP",
    "section": "6.3 Performance Illustration",
    "text": "6.3 Performance Illustration\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv(\"/Users/klian/dev/books/metaheuristics-java/data/gap/perf_records_ga.csv\", names=['iteration', 'curr_obj', 'best_obj'])\n\n\ndf\n\n\n\n\n\n\n\n\n\niteration\ncurr_obj\nbest_obj\n\n\n\n\n0\n0\n76088\n37289\n\n\n1\n1\n46838\n17288\n\n\n2\n2\n32506\n11302\n\n\n3\n3\n21643\n8301\n\n\n4\n4\n13734\n8301\n\n\n...\n...\n...\n...\n\n\n996\n996\n255\n255\n\n\n997\n997\n255\n255\n\n\n998\n998\n255\n255\n\n\n999\n999\n255\n255\n\n\n1000\n1000\n255\n255\n\n\n\n\n1001 rows × 3 columns\n\n\n\n\n\nfig, ax = plt.subplots(1, 1, figsize=(12, 4))\nax.plot(df['iteration'], df['curr_obj'], 'g--', label=\"current objective\")\nax.plot(df['iteration'], df['best_obj'], 'r--', label=\"best objective\")\nax.legend()\n\nax.set_xlim([0, 100])\nax.set_ylim([0, 80000])",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Genetic Algorithm for GAP</span>"
    ]
  },
  {
    "objectID": "gap-sa.html",
    "href": "gap-sa.html",
    "title": "7  Simulated Annealing for GAP",
    "section": "",
    "text": "7.1 Algorithm Design",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Simulated Annealing for GAP</span>"
    ]
  },
  {
    "objectID": "gap-sa.html#implementation-details",
    "href": "gap-sa.html#implementation-details",
    "title": "7  Simulated Annealing for GAP",
    "section": "7.2 Implementation Details",
    "text": "7.2 Implementation Details\n\n\n\nListing 7.1: The solution class\n\n\n\n\nGapSolution.java\n\npackage com.voyager.opt.metaheuristics.gap;\n\nimport lombok.Getter;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.stream.IntStream;\n\n@Getter\npublic final class GapSolution {\n  /**\n   * reference to the instance to be solved\n   */\n  private final GapInstance instance;\n  /**\n   * dimension: 1 * numTasks\n   * assigned agent index for each task\n   */\n  private final int[] agentAssignments;\n  /**\n   * dimension: 1 * numAgents\n   * consumed capacity of each agent\n   */\n  private final int[] consumedCapacities;\n  /**\n   * total objective value\n   */\n  private int objective;\n  /**\n   * assignment cost, without penalties\n   */\n  private int assignmentCost;\n  /**\n   * capacity violation penalties of all agents\n   */\n  private int capacityViolationPenalty;\n\n  public GapSolution(GapInstance instance) {\n    this.instance = instance;\n    this.agentAssignments = new int[this.instance.getNumTasks()];\n    this.consumedCapacities = new int[this.instance.getNumAgents()];\n    Arrays.fill(this.agentAssignments, 0);\n    Arrays.fill(consumedCapacities, 0);\n    this.objective = 0;\n    this.assignmentCost = 0;\n    this.capacityViolationPenalty = 0;\n  }\n\n  /**\n   * copy constructor\n   * @param other the other solution to copy from\n   */\n  public GapSolution(GapSolution other) {\n    this.instance = other.instance;\n    this.agentAssignments = new int[this.instance.getNumTasks()];\n    System.arraycopy(other.agentAssignments, 0,\n      this.agentAssignments, 0,\n      this.instance.getNumTasks());\n    this.consumedCapacities = new int[this.instance.getNumAgents()];\n    System.arraycopy(other.consumedCapacities, 0,\n      this.consumedCapacities, 0,\n      this.instance.getNumAgents());\n    this.objective = other.objective;\n    this.assignmentCost = other.assignmentCost;\n    this.capacityViolationPenalty = other.capacityViolationPenalty;\n  }\n\n  /**\n   * randomly assign tasks to agents\n   * @param random random number generator\n   */\n  public void initialize(Random random) {\n    int[][] resources = this.instance.getResources();\n    for (int i = 0; i &lt; instance.getNumTasks(); i++) {\n      int agentIdx = random.nextInt(instance.getNumAgents());\n      this.agentAssignments[i] = agentIdx;\n      this.consumedCapacities[agentIdx] += resources[agentIdx][i];\n    }\n  }\n\n  /**\n   * compute objective values\n   * @param capacityViolationPenalty penalty factor\n   */\n  public void computeObjective(int capacityViolationPenalty) {\n    // compute assignment costs\n    this.assignmentCost = IntStream.range(0, instance.getNumTasks())\n      .map(taskIdx -&gt; instance.getCosts()[agentAssignments[taskIdx]][taskIdx])\n      .sum();\n\n    // compute capacity violation costs\n    this.capacityViolationPenalty = IntStream.range(0, instance.getNumAgents())\n      .map(agentIdx -&gt; capacityViolationPenalty *\n        Math.max(0, this.consumedCapacities[agentIdx] - instance.getCapacities()[agentIdx]))\n      .sum();\n\n    this.objective = this.assignmentCost + this.capacityViolationPenalty;\n  }\n\n  public int getAssignedAgent(int taskIdx) {\n    return this.agentAssignments[taskIdx];\n  }\n\n  /**\n   * assign agent to task\n   * @param taskIdx the task to be assigned\n   * @param agentIdx the agent index\n   */\n  public void setAssignedAgent(int taskIdx, int agentIdx) {\n    int currAgentIdx = this.agentAssignments[taskIdx];\n    this.agentAssignments[taskIdx] = agentIdx;\n    this.consumedCapacities[currAgentIdx] -= instance.getResources()[currAgentIdx][taskIdx];\n    this.consumedCapacities[agentIdx] += instance.getResources()[agentIdx][taskIdx];\n  }\n}\n\n\n\n\n\n\n\nListing 7.2: Simulated annealing implementation\n\n\n\n\nGapSimulatedAnnealing.java\n\npackage com.voyager.opt.metaheuristics.gap.sa;\n\nimport com.voyager.opt.metaheuristics.gap.GapInstance;\nimport com.voyager.opt.metaheuristics.gap.GapInstanceReader;\nimport com.voyager.opt.metaheuristics.gap.GapSolution;\nimport com.voyager.opt.metaheuristics.utils.PerfRecord;\nimport com.voyager.opt.metaheuristics.utils.PerfRecordsWriter;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URISyntaxException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\n@Getter\n@Setter\npublic class GapSimulatedAnnealing {\n  /**\n   * instance to be solved\n   */\n  private final GapInstance instance;\n  /**\n   * random number generator\n   */\n  private final Random random;\n  /**\n   * best solution\n   */\n  private GapSolution bestSolution;\n  /**\n   * performance records\n   */\n  private List&lt;PerfRecord&lt;Integer&gt;&gt; perfRecords;\n\n  public GapSimulatedAnnealing(GapInstance instance) {\n    this.instance = instance;\n    this.random = new Random(42);\n    this.bestSolution = null;\n    this.perfRecords = new ArrayList&lt;&gt;();\n  }\n\n  public void solve() {\n    // penalty factor for capacity violation\n    int capacityViolationPenalty = 1000;\n    double initialTemperature = 1000;\n    double coolingRate = 0.9999;\n    double endingTemperature = 0.0001;\n    int iterationsPerTemperature = 100;\n\n    // create a starting solution\n    GapSolution currSolution = new GapSolution(this.instance);\n    currSolution.initialize(this.random);\n    currSolution.computeObjective(capacityViolationPenalty);\n    this.bestSolution = currSolution;\n    this.perfRecords.add(new PerfRecord&lt;&gt;(0,\n      currSolution.getObjective(),\n      bestSolution.getObjective()));\n\n    int numTasks = this.instance.getNumTasks();\n    int numAgents = this.instance.getNumAgents();\n\n    // Set initial temperature\n    double temperature = initialTemperature;\n\n    while (temperature &gt; endingTemperature) {\n      System.out.println(\"temperature: \" + temperature +\n        \", curr_obj: \" + currSolution.getObjective() +\n        \", best_obj: \" + bestSolution.getObjective());\n      for (int i = 0; i &lt; iterationsPerTemperature; i++) {\n        // Generate neighbor solution\n        GapSolution newSolution = new GapSolution(currSolution);\n\n        // mutate one task assignment\n        int randTaskIdx = this.random.nextInt(numTasks);\n        int currAgentIdx = newSolution.getAssignedAgent(randTaskIdx);\n        int newAgentIdx = this.random.nextInt(numAgents);\n        while (newAgentIdx == currAgentIdx) {\n          newAgentIdx = this.random.nextInt(numAgents);\n        }\n        newSolution.setAssignedAgent(randTaskIdx, newAgentIdx);\n\n        // compute objective value after mutation\n        newSolution.computeObjective(capacityViolationPenalty);\n\n        // Calculate cost differences\n        int deltaCost = newSolution.getObjective() - currSolution.getObjective();\n\n        // Accept or reject neighbor solution based on Metropolis criterion\n        if (deltaCost &lt; 0 || Math.exp(-deltaCost / temperature) &gt; random.nextDouble()) {\n          currSolution = newSolution;\n        }\n\n        // Update best assignment\n        if (currSolution.getObjective() &lt; bestSolution.getObjective()) {\n          bestSolution = currSolution;\n        }\n      }\n\n      // Cool down temperature\n      temperature *= coolingRate;\n    }\n  }\n\n  public static void main(String[] args) throws IOException, URISyntaxException {\n    File file = new File(\"src/main/resources/data/gap/gap1.txt\");\n    String filePath = file.getAbsolutePath();\n    String outputFilename = \"/Users/klian/dev/books/metaheuristics-java/data/gap/perf_records_sa.csv\";\n    List&lt;GapInstance&gt; instances = GapInstanceReader.read(filePath);\n\n    GapInstance instance = instances.get(1);\n    GapSimulatedAnnealing simulatedAnnealing = new GapSimulatedAnnealing(instance);\n    simulatedAnnealing.solve();\n\n    // save performance records\n    PerfRecordsWriter.write(outputFilename, simulatedAnnealing.getPerfRecords());\n  }\n}",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Simulated Annealing for GAP</span>"
    ]
  },
  {
    "objectID": "gap-sa.html#performance-illustration",
    "href": "gap-sa.html#performance-illustration",
    "title": "7  Simulated Annealing for GAP",
    "section": "7.3 Performance Illustration",
    "text": "7.3 Performance Illustration\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv(\"/Users/klian/dev/books/metaheuristics-java/data/gap/perf_records_sa.csv\", names=['iteration', 'curr_obj', 'best_obj'])\ndf\n\n\n\n\n\n\n\n\n\niteration\ncurr_obj\nbest_obj\n\n\n\n\n0\n0\n79294\n79294\n\n\n1\n1\n15298\n14297\n\n\n2\n2\n14297\n14297\n\n\n3\n3\n10292\n10292\n\n\n4\n4\n10292\n10292\n\n\n...\n...\n...\n...\n\n\n161168\n161168\n291\n271\n\n\n161169\n161169\n291\n271\n\n\n161170\n161170\n291\n271\n\n\n161171\n161171\n291\n271\n\n\n161172\n161172\n291\n271\n\n\n\n\n161173 rows × 3 columns\n\n\n\n\n\nfig, ax = plt.subplots(1, 1, figsize=(12, 4))\nax.plot(df['iteration'], df['curr_obj'], 'g--', label=\"current objective\")\nax.plot(df['iteration'], df['best_obj'], 'r--', label=\"best objective\")\nax.legend()\n\nax.set_xlim([0, 100])\nax.set_ylim([0, 80000])",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Simulated Annealing for GAP</span>"
    ]
  },
  {
    "objectID": "gap-ts.html",
    "href": "gap-ts.html",
    "title": "8  Tabu Search for GAP",
    "section": "",
    "text": "8.1 Algorithm Design",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tabu Search for GAP</span>"
    ]
  },
  {
    "objectID": "gap-ts.html#algorithm-design",
    "href": "gap-ts.html#algorithm-design",
    "title": "8  Tabu Search for GAP",
    "section": "",
    "text": "8.1.1 Solution representation\n\n\n8.1.2 Neighborhood structure\n\n\n8.1.3 Tabu table design",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tabu Search for GAP</span>"
    ]
  },
  {
    "objectID": "gap-ts.html#implementation-details-in-java",
    "href": "gap-ts.html#implementation-details-in-java",
    "title": "8  Tabu Search for GAP",
    "section": "8.2 Implementation Details in Java",
    "text": "8.2 Implementation Details in Java\nIn this section, we present an implementation of Tabu Search in Java.\n\n8.2.1 Source file structure\nsrc/main/java\n└── com\n    └── voyager\n        └── opt\n            └── metaheuristics\n                ├── gap\n                │   ├── GapInstance.java\n                │   ├── GapInstanceReader.java\n                │   ├── GapSolution.java\n                │   └── tabu\n                │       ├── GapSolutionNeighbor.java\n                │       └── GapTabuSearch.java\n                └── utils\n                    ├── PerfRecord.java\n                    └── PerfRecordsWriter.java\n\n\n8.2.2 Java classes and explanations\n\n\nGapInstance.java\n\npackage com.voyager.opt.metaheuristics.gap;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\n\n@Data\n@Builder\n@AllArgsConstructor\npublic class GapInstance {\n  /**\n   * total number of tasks\n   */\n  private int numTasks;\n  /**\n   * total number of agents\n   */\n  private int numAgents;\n  /**\n   * costs of assigning tasks to agents\n   */\n  private int[][] costs;\n  /**\n   * resource consumption of assigning tasks to agents\n   */\n  private int[][] resources;\n  /**\n   * agent capacities\n   */\n  private int[] capacities;\n}\n\n\n\nGapSolution.java\n\npackage com.voyager.opt.metaheuristics.gap;\n\nimport lombok.Getter;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.stream.IntStream;\n\n@Getter\npublic final class GapSolution {\n  /**\n   * reference to the instance to be solved\n   */\n  private final GapInstance instance;\n  /**\n   * dimension: 1 * numTasks\n   * assigned agent index for each task\n   */\n  private final int[] agentAssignments;\n  /**\n   * dimension: 1 * numAgents\n   * consumed capacity of each agent\n   */\n  private final int[] consumedCapacities;\n  /**\n   * total objective value\n   */\n  private int objective;\n  /**\n   * assignment cost, without penalties\n   */\n  private int assignmentCost;\n  /**\n   * capacity violation penalties of all agents\n   */\n  private int capacityViolationPenalty;\n\n  public GapSolution(GapInstance instance) {\n    this.instance = instance;\n    this.agentAssignments = new int[this.instance.getNumTasks()];\n    this.consumedCapacities = new int[this.instance.getNumAgents()];\n    Arrays.fill(this.agentAssignments, 0);\n    Arrays.fill(consumedCapacities, 0);\n    this.objective = 0;\n    this.assignmentCost = 0;\n    this.capacityViolationPenalty = 0;\n  }\n\n  /**\n   * copy constructor\n   * @param other the other solution to copy from\n   */\n  public GapSolution(GapSolution other) {\n    this.instance = other.instance;\n    this.agentAssignments = new int[this.instance.getNumTasks()];\n    System.arraycopy(other.agentAssignments, 0,\n      this.agentAssignments, 0,\n      this.instance.getNumTasks());\n    this.consumedCapacities = new int[this.instance.getNumAgents()];\n    System.arraycopy(other.consumedCapacities, 0,\n      this.consumedCapacities, 0,\n      this.instance.getNumAgents());\n    this.objective = other.objective;\n    this.assignmentCost = other.assignmentCost;\n    this.capacityViolationPenalty = other.capacityViolationPenalty;\n  }\n\n  /**\n   * randomly assign tasks to agents\n   * @param random random number generator\n   */\n  public void initialize(Random random) {\n    int[][] resources = this.instance.getResources();\n    for (int i = 0; i &lt; instance.getNumTasks(); i++) {\n      int agentIdx = random.nextInt(instance.getNumAgents());\n      this.agentAssignments[i] = agentIdx;\n      this.consumedCapacities[agentIdx] += resources[agentIdx][i];\n    }\n  }\n\n  /**\n   * compute objective values\n   * @param capacityViolationPenalty penalty factor\n   */\n  public void computeObjective(int capacityViolationPenalty) {\n    // compute assignment costs\n    this.assignmentCost = IntStream.range(0, instance.getNumTasks())\n      .map(taskIdx -&gt; instance.getCosts()[agentAssignments[taskIdx]][taskIdx])\n      .sum();\n\n    // compute capacity violation costs\n    this.capacityViolationPenalty = IntStream.range(0, instance.getNumAgents())\n      .map(agentIdx -&gt; capacityViolationPenalty *\n        Math.max(0, this.consumedCapacities[agentIdx] - instance.getCapacities()[agentIdx]))\n      .sum();\n\n    this.objective = this.assignmentCost + this.capacityViolationPenalty;\n  }\n\n  public int getAssignedAgent(int taskIdx) {\n    return this.agentAssignments[taskIdx];\n  }\n\n  /**\n   * assign agent to task\n   * @param taskIdx the task to be assigned\n   * @param agentIdx the agent index\n   */\n  public void setAssignedAgent(int taskIdx, int agentIdx) {\n    int currAgentIdx = this.agentAssignments[taskIdx];\n    this.agentAssignments[taskIdx] = agentIdx;\n    this.consumedCapacities[currAgentIdx] -= instance.getResources()[currAgentIdx][taskIdx];\n    this.consumedCapacities[agentIdx] += instance.getResources()[agentIdx][taskIdx];\n  }\n}\n\n\n\nGapSolutionNeighbor.java\n\npackage com.voyager.opt.metaheuristics.gap.tabu;\n\nimport com.voyager.opt.metaheuristics.gap.GapSolution;\nimport lombok.Builder;\nimport lombok.Getter;\n\n@Getter\n@Builder\npublic class GapSolutionNeighbor {\n  /**\n   * neighboring solution\n   */\n  private GapSolution newSolution;\n  /**\n   * the task for which agent assignment is changed\n   */\n  private int mutatedTaskIdx;\n  /**\n   * new agent index for the chosen task\n   */\n  private int newAgentIdx;\n}\n\n\n\nGapTabuSearch\n\npackage com.voyager.opt.metaheuristics.gap.tabu;\n\nimport com.voyager.opt.metaheuristics.gap.GapInstance;\nimport com.voyager.opt.metaheuristics.gap.GapInstanceReader;\nimport com.voyager.opt.metaheuristics.gap.GapSolution;\nimport com.voyager.opt.metaheuristics.utils.PerfRecord;\nimport com.voyager.opt.metaheuristics.utils.PerfRecordsWriter;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.*;\n\n@Getter\n@Setter\npublic final class GapTabuSearch {\n  /**\n   * instance to be solved\n   */\n  private final GapInstance instance;\n  /**\n   * random number generator\n   */\n  private final Random random;\n  /**\n   * tabu table\n   */\n  private final int[][] tabuTable;\n  /**\n   * best solution\n   */\n  private GapSolution bestSolution;\n  private List&lt;PerfRecord&lt;Integer&gt;&gt; perfRecords;\n\n  public GapTabuSearch(GapInstance instance) {\n    this.instance = instance;\n    this.random = new Random(42);\n    int numTasks = instance.getNumTasks();\n    this.tabuTable = new int[numTasks][instance.getNumAgents()];\n    for (int i = 0; i &lt; numTasks; i++) {\n      Arrays.fill(this.tabuTable[i], 0);\n    }\n\n    this.bestSolution = null;\n    this.perfRecords = new ArrayList&lt;&gt;();\n  }\n\n  public void solve() {\n    // penalty factor for capacity violation\n    int capacityViolationPenalty = 1000;\n\n    // tabu search parameters\n    int neighSize = 100;\n    int tabuLength = 100;\n\n    // stopping criteria\n    int maxIter = 2000;\n    int maxIterNoImprove = 500;\n\n    // create a starting solution\n    GapSolution currSolution = new GapSolution(this.instance);\n    currSolution.initialize(this.random);\n    currSolution.computeObjective(capacityViolationPenalty);\n    this.bestSolution = currSolution;\n    this.perfRecords.add(new PerfRecord&lt;&gt;(0,\n      currSolution.getObjective(),\n      bestSolution.getObjective()));\n\n    int numTasks = this.instance.getNumTasks();\n    int numAgents = this.instance.getNumAgents();\n\n    // main workflow\n    int iter = 0;\n    int iterNoImprove = 0;\n    while (true) {\n      System.out.println(\"iter: \" + iter + \", best obj: \" + bestSolution.getObjective());\n      // create neighboring solutions\n      List&lt;GapSolutionNeighbor&gt; neighbors = new ArrayList&lt;&gt;(neighSize);\n      for (int i = 0; i &lt; neighSize; i++) {\n        // create a copy of current solution\n        GapSolution newSolution = new GapSolution(currSolution);\n\n        // mutate one task assignment\n        int randTaskIdx = this.random.nextInt(numTasks);\n        int currAgentIdx = newSolution.getAssignedAgent(randTaskIdx);\n        int newAgentIdx = this.random.nextInt(numAgents);\n        while (newAgentIdx == currAgentIdx) {\n          newAgentIdx = this.random.nextInt(numAgents);\n        }\n        newSolution.setAssignedAgent(randTaskIdx, newAgentIdx);\n\n        // compute objective value after mutation\n        newSolution.computeObjective(capacityViolationPenalty);\n\n        GapSolutionNeighbor neighbor = GapSolutionNeighbor.builder()\n          .newSolution(newSolution)\n          .mutatedTaskIdx(randTaskIdx)\n          .newAgentIdx(newAgentIdx)\n          .build();\n        neighbors.add(neighbor);\n      }\n\n      // sort neighboring solutions\n      neighbors.sort(Comparator.comparingInt(neighbor -&gt; neighbor.getNewSolution().getObjective()));\n\n      boolean currSolutionUpdated = false;\n      boolean bestSolutionUpdated = false;\n      // check tabu criteria\n      for (GapSolutionNeighbor neighbor : neighbors) {\n        GapSolution newSolution = neighbor.getNewSolution();\n        int mutatedTaskIdx = neighbor.getMutatedTaskIdx();\n        int newAgentIdx = neighbor.getNewAgentIdx();\n\n        if (this.tabuTable[mutatedTaskIdx][newAgentIdx] &lt; iter) {\n          // this move is not tabooed, proceed\n          currSolution = newSolution;\n          currSolutionUpdated = true;\n          this.tabuTable[mutatedTaskIdx][newAgentIdx] = iter + tabuLength;\n\n          if (currSolution.getObjective() &lt; this.bestSolution.getObjective()) {\n            this.bestSolution = currSolution;\n            bestSolutionUpdated = true;\n            break;\n          }\n        } else {\n          // check aspiration criterion\n          if (newSolution.getObjective() &lt; bestSolution.getObjective()) {\n            currSolution = newSolution;\n            bestSolution = currSolution;\n            currSolutionUpdated = true;\n            bestSolutionUpdated = true;\n            this.tabuTable[mutatedTaskIdx][newAgentIdx] = iter + tabuLength;\n            break;\n          }\n        }\n      }\n\n      // in case no move is possible, choose the best neighbor\n      if (!currSolutionUpdated) {\n        GapSolutionNeighbor neighbor = neighbors.getFirst();\n        currSolution = neighbor.getNewSolution();\n        this.tabuTable[neighbor.getMutatedTaskIdx()][neighbor.getNewAgentIdx()] = iter + tabuLength;\n      }\n\n      iter++;\n      this.perfRecords.add(new PerfRecord&lt;&gt;(iter,\n        currSolution.getObjective(),\n        bestSolution.getObjective()));\n\n      // check stopping criteria\n      iterNoImprove = bestSolutionUpdated ? 0 : iterNoImprove + 1;\n      if (iter &gt;= maxIter || iterNoImprove &gt;= maxIterNoImprove) {\n        break;\n      }\n    }\n  }\n\n  public void savePerfRecords(String filename) {\n    PerfRecordsWriter.write(filename, perfRecords);\n  }\n\n  public static void main(String[] args) {\n    String filename = \"/Users/klian/dev/metaheuristics-java-code/src/main/resources/data/gap/gap1.txt\";\n    String outputFilename = \"/Users/klian/dev/books/metaheuristics-java/data/gap/perf_records.txt\";\n    List&lt;GapInstance&gt; instances = GapInstanceReader.read(filename);\n\n    GapInstance instance = instances.get(1);\n    GapTabuSearch tabuSearch = new GapTabuSearch(instance);\n    tabuSearch.solve();\n    tabuSearch.savePerfRecords(outputFilename);\n  }\n}",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tabu Search for GAP</span>"
    ]
  },
  {
    "objectID": "gap-ts.html#performance-illustration",
    "href": "gap-ts.html#performance-illustration",
    "title": "8  Tabu Search for GAP",
    "section": "8.3 Performance Illustration",
    "text": "8.3 Performance Illustration\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv(\"/Users/klian/dev/books/metaheuristics-java/data/gap/perf_records_ts.csv\", names=['iteration', 'curr_obj', 'best_obj'])\n\n\ndf\n\n\n\n\n\n\n\n\n\niteration\ncurr_obj\nbest_obj\n\n\n\n\n0\n0\n79294\n79294\n\n\n1\n1\n56291\n56291\n\n\n2\n2\n43294\n43294\n\n\n3\n3\n32300\n32300\n\n\n4\n4\n29306\n29306\n\n\n...\n...\n...\n...\n\n\n554\n554\n7294\n273\n\n\n555\n555\n1291\n273\n\n\n556\n556\n3297\n273\n\n\n557\n557\n1291\n273\n\n\n558\n558\n6288\n273\n\n\n\n\n559 rows × 3 columns\n\n\n\n\n\nfig, ax = plt.subplots(1, 1, figsize=(12, 4))\nax.plot(df['iteration'], df['curr_obj'], 'g--', label=\"current objective\")\nax.plot(df['iteration'], df['best_obj'], 'r--', label=\"best objective\")\nax.legend()\n\nax.set_xlim([0, 100])\nax.set_ylim([0, 80000])",
    "crumbs": [
      "Generalized Assignment Problem (GAP)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tabu Search for GAP</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "9  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Sörensen, Kenneth. 2015. “Metaheuristics—the Metaphor\nExposed.” International Transactions in Operational\nResearch 22 (1): 3–18. https://doi.org/10.1111/itor.12001.",
    "crumbs": [
      "References"
    ]
  }
]
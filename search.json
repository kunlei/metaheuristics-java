[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Metaheuristics in Java",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "gap-intro.html",
    "href": "gap-intro.html",
    "title": "5  Generalized Assignment Problem",
    "section": "",
    "text": "5.1 Problem Statement\nFormally, the Generalized Assignment Problem can be defined as follows:\nGiven:\nThe goal is to find an assignment of tasks to agents that minimizes the total cost or maximizes the total profit, while ensuring that each task is assigned to one or more agents, and the total resource requirement of each agent does not exceed its capacity.\nMathematically, the GAP can be formulated as an integer linear programming problem. One possible formulation is as follows:\n\\[\n\\begin{aligned}\n\\text{min.} &\\quad \\sum_{i=1}^{n} \\sum_{j=1}^{m} c_{ij} x_{ij} \\label{gap-obj}\\\\\n\\text{s.t.} &\\quad \\sum_{j=1}^{m} x_{ij} = 1, \\ \\forall i = 1, 2, ..., n \\label{gap-cons1}\\\\\n&\\quad \\sum_{i=1}^{n} r_{ij} x_{ij} \\leq b_j, \\  \\forall j = 1, 2, ..., m \\label{gap-cons2}\\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall i = 1, 2, ..., n, j = 1, 2, ..., m \\label{gap-cons3}\n\\end{aligned}\n\\]\nwhere \\(x_{ij}\\) is a binary decision variable that equals 1 if task \\(i\\) is assigned to agent \\(j\\), and 0 otherwise.\nThe first set of constraints ensures that each task is assigned to exactly one agent, and the second set of constraints ensures that the total resource requirement of each agent does not exceed its capacity.\nSolving the GAP can be computationally challenging, especially for large instances, as it is a generalization of the classic assignment problem, which is known to be polynomial-time solvable. Various algorithms and heuristics, such as branch and bound, dynamic programming, and approximation algorithms, can be employed to find feasible or optimal solutions to the GAP.",
    "crumbs": [
      "Generalized Assignment Problem",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "gap-intro.html#problem-statement",
    "href": "gap-intro.html#problem-statement",
    "title": "5  Generalized Assignment Problem",
    "section": "",
    "text": "A set of tasks, \\(T = \\{1, 2, ..., n\\}\\)\nA set of agents, \\(A = \\{1, 2, ..., m\\}\\)\nFor each task \\(i\\) and agent \\(j\\), a cost or profit \\(c_{ij}\\) associated with assigning task \\(i\\) to agent \\(j\\)\nFor each task \\(i\\) and agent \\(j\\), a resource requirement \\(r_{ij}\\) specifying the amount of resource needed from agent \\(j\\) to complete task \\(i\\)\nFor each agent \\(j\\), a capacity \\(b_j\\) specifying the maximum amount of resource that agent \\(j\\) can contribute",
    "crumbs": [
      "Generalized Assignment Problem",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "gap-intro.html#benchmarking-problems",
    "href": "gap-intro.html#benchmarking-problems",
    "title": "5  Generalized Assignment Problem",
    "section": "5.2 Benchmarking Problems",
    "text": "5.2 Benchmarking Problems",
    "crumbs": [
      "Generalized Assignment Problem",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "gap-ts.html",
    "href": "gap-ts.html",
    "title": "8  Tabu Search for Generalized Assignment Problem",
    "section": "",
    "text": "8.1 Algorithm Design",
    "crumbs": [
      "Generalized Assignment Problem",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tabu Search for Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "gap-ts.html#algorithm-design",
    "href": "gap-ts.html#algorithm-design",
    "title": "8  Tabu Search for Generalized Assignment Problem",
    "section": "",
    "text": "8.1.1 Solution representation\n\n\n8.1.2 Neighborhood structure\n\n\n8.1.3 Tabu table design",
    "crumbs": [
      "Generalized Assignment Problem",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tabu Search for Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "gap-ts.html#implementation-in-java",
    "href": "gap-ts.html#implementation-in-java",
    "title": "8  Tabu Search for Generalized Assignment Problem",
    "section": "8.2 Implementation in Java",
    "text": "8.2 Implementation in Java\n\n8.2.1 Source file structure\nsrc/main/java\n└── com\n    └── voyager\n        └── opt\n            └── metaheuristics\n                ├── gap\n                │   ├── GapInstance.java\n                │   ├── GapInstanceReader.java\n                │   ├── GapSolution.java\n                │   └── tabu\n                │       ├── GapSolutionNeighbor.java\n                │       └── GapTabuSearch.java\n                └── utils\n                    ├── PerfRecord.java\n                    └── PerfRecordsWriter.java\n\n\n8.2.2 Java classes and explanations\n\n\nGapInstance.java\n\npackage com.voyager.opt.metaheuristics.gap;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\n\n@Data\n@Builder\n@AllArgsConstructor\npublic class GapInstance {\n  /**\n   * total number of tasks\n   */\n  private int numTasks;\n  /**\n   * total number of agents\n   */\n  private int numAgents;\n  /**\n   * costs of assigning tasks to agents\n   */\n  private int[][] costs;\n  /**\n   * resource consumption of assigning tasks to agents\n   */\n  private int[][] resources;\n  /**\n   * agent capacities\n   */\n  private int[] capacities;\n}\n\n\n\nGapSolution.java\n\npackage com.voyager.opt.metaheuristics.gap;\n\nimport lombok.Getter;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.stream.IntStream;\n\n@Getter\npublic final class GapSolution {\n  /**\n   * reference to the instance to be solved\n   */\n  private final GapInstance instance;\n  /**\n   * dimension: 1 * numTasks\n   * assigned agent index for each task\n   */\n  private final int[] agentAssignments;\n  /**\n   * dimension: 1 * numAgents\n   * consumed capacity of each agent\n   */\n  private final int[] consumedCapacities;\n  /**\n   * total objective value\n   */\n  private int objective;\n  /**\n   * assignment cost, without penalties\n   */\n  private int assignmentCost;\n  /**\n   * capacity violation penalties of all agents\n   */\n  private int capacityViolationPenalty;\n\n  public GapSolution(GapInstance instance) {\n    this.instance = instance;\n    this.agentAssignments = new int[this.instance.getNumTasks()];\n    this.consumedCapacities = new int[this.instance.getNumAgents()];\n    Arrays.fill(this.agentAssignments, 0);\n    Arrays.fill(consumedCapacities, 0);\n    this.objective = 0;\n    this.assignmentCost = 0;\n    this.capacityViolationPenalty = 0;\n  }\n\n  /**\n   * copy constructor\n   * @param other the other solution to copy from\n   */\n  public GapSolution(GapSolution other) {\n    this.instance = other.instance;\n    this.agentAssignments = new int[this.instance.getNumTasks()];\n    System.arraycopy(other.agentAssignments, 0,\n      this.agentAssignments, 0,\n      this.instance.getNumTasks());\n    this.consumedCapacities = new int[this.instance.getNumAgents()];\n    System.arraycopy(other.consumedCapacities, 0,\n      this.consumedCapacities, 0,\n      this.instance.getNumAgents());\n    this.objective = other.objective;\n    this.assignmentCost = other.assignmentCost;\n    this.capacityViolationPenalty = other.capacityViolationPenalty;\n  }\n\n  /**\n   * randomly assign tasks to agents\n   * @param random random number generator\n   */\n  public void initialize(Random random) {\n    int[][] resources = this.instance.getResources();\n    for (int i = 0; i &lt; instance.getNumTasks(); i++) {\n      int agentIdx = random.nextInt(instance.getNumAgents());\n      this.agentAssignments[i] = agentIdx;\n      this.consumedCapacities[agentIdx] += resources[agentIdx][i];\n    }\n  }\n\n  /**\n   * compute objective values\n   * @param capacityViolationPenalty penalty factor\n   */\n  public void computeObjective(int capacityViolationPenalty) {\n    // compute assignment costs\n    this.assignmentCost = IntStream.range(0, instance.getNumTasks())\n      .map(taskIdx -&gt; instance.getCosts()[agentAssignments[taskIdx]][taskIdx])\n      .sum();\n\n    // compute capacity violation costs\n    this.capacityViolationPenalty = IntStream.range(0, instance.getNumAgents())\n      .map(agentIdx -&gt; capacityViolationPenalty *\n        Math.max(0, this.consumedCapacities[agentIdx] - instance.getCapacities()[agentIdx]))\n      .sum();\n\n    this.objective = this.assignmentCost + this.capacityViolationPenalty;\n  }\n\n  public int getAssignedAgent(int taskIdx) {\n    return this.agentAssignments[taskIdx];\n  }\n\n  /**\n   * assign agent to task\n   * @param taskIdx the task to be assigned\n   * @param agentIdx the agent index\n   */\n  public void setAssignedAgent(int taskIdx, int agentIdx) {\n    int currAgentIdx = this.agentAssignments[taskIdx];\n    this.agentAssignments[taskIdx] = agentIdx;\n    this.consumedCapacities[currAgentIdx] -= instance.getResources()[currAgentIdx][taskIdx];\n    this.consumedCapacities[agentIdx] += instance.getResources()[agentIdx][taskIdx];\n  }\n}\n\n\n\nGapSolutionNeighbor.java\n\npackage com.voyager.opt.metaheuristics.gap.tabu;\n\nimport com.voyager.opt.metaheuristics.gap.GapSolution;\nimport lombok.Builder;\nimport lombok.Getter;\n\n@Getter\n@Builder\npublic class GapSolutionNeighbor {\n  /**\n   * neighboring solution\n   */\n  private GapSolution newSolution;\n  /**\n   * the task for which agent assignment is changed\n   */\n  private int mutatedTaskIdx;\n  /**\n   * new agent index for the chosen task\n   */\n  private int newAgentIdx;\n}\n\n\n\nGapTabuSearch\n\npackage com.voyager.opt.metaheuristics.gap.tabu;\n\nimport com.voyager.opt.metaheuristics.gap.GapInstance;\nimport com.voyager.opt.metaheuristics.gap.GapInstanceReader;\nimport com.voyager.opt.metaheuristics.gap.GapSolution;\nimport com.voyager.opt.metaheuristics.utils.PerfRecord;\nimport com.voyager.opt.metaheuristics.utils.PerfRecordsWriter;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.*;\n\n@Getter\n@Setter\npublic final class GapTabuSearch {\n  /**\n   * instance to be solved\n   */\n  private final GapInstance instance;\n  /**\n   * random number generator\n   */\n  private final Random random;\n  /**\n   * tabu table\n   */\n  private final int[][] tabuTable;\n  /**\n   * best solution\n   */\n  private GapSolution bestSolution;\n  private List&lt;PerfRecord&lt;Integer&gt;&gt; perfRecords;\n\n  public GapTabuSearch(GapInstance instance) {\n    this.instance = instance;\n    this.random = new Random(42);\n    int numTasks = instance.getNumTasks();\n    this.tabuTable = new int[numTasks][instance.getNumAgents()];\n    for (int i = 0; i &lt; numTasks; i++) {\n      Arrays.fill(this.tabuTable[i], 0);\n    }\n\n    this.bestSolution = null;\n    this.perfRecords = new ArrayList&lt;&gt;();\n  }\n\n  public void solve() {\n    // penalty factor for capacity violation\n    int capacityViolationPenalty = 1000;\n\n    // tabu search parameters\n    int neighSize = 100;\n    int tabuLength = 100;\n\n    // stopping criteria\n    int maxIter = 2000;\n    int maxIterNoImprove = 500;\n\n    // create a starting solution\n    GapSolution currSolution = new GapSolution(this.instance);\n    currSolution.initialize(this.random);\n    currSolution.computeObjective(capacityViolationPenalty);\n    this.bestSolution = currSolution;\n    this.perfRecords.add(new PerfRecord&lt;&gt;(0,\n      currSolution.getObjective(),\n      bestSolution.getObjective()));\n\n    int numTasks = this.instance.getNumTasks();\n    int numAgents = this.instance.getNumAgents();\n\n    // main workflow\n    int iter = 0;\n    int iterNoImprove = 0;\n    while (true) {\n      System.out.println(\"iter: \" + iter + \", best obj: \" + bestSolution.getObjective());\n      // create neighboring solutions\n      List&lt;GapSolutionNeighbor&gt; neighbors = new ArrayList&lt;&gt;(neighSize);\n      for (int i = 0; i &lt; neighSize; i++) {\n        // create a copy of current solution\n        GapSolution newSolution = new GapSolution(currSolution);\n\n        // mutate one task assignment\n        int randTaskIdx = this.random.nextInt(numTasks);\n        int currAgentIdx = newSolution.getAssignedAgent(randTaskIdx);\n        int newAgentIdx = this.random.nextInt(numAgents);\n        while (newAgentIdx == currAgentIdx) {\n          newAgentIdx = this.random.nextInt(numAgents);\n        }\n        newSolution.setAssignedAgent(randTaskIdx, newAgentIdx);\n\n        // compute objective value after mutation\n        newSolution.computeObjective(capacityViolationPenalty);\n\n        GapSolutionNeighbor neighbor = GapSolutionNeighbor.builder()\n          .newSolution(newSolution)\n          .mutatedTaskIdx(randTaskIdx)\n          .newAgentIdx(newAgentIdx)\n          .build();\n        neighbors.add(neighbor);\n      }\n\n      // sort neighboring solutions\n      neighbors.sort(Comparator.comparingInt(neighbor -&gt; neighbor.getNewSolution().getObjective()));\n\n      boolean currSolutionUpdated = false;\n      boolean bestSolutionUpdated = false;\n      // check tabu criteria\n      for (GapSolutionNeighbor neighbor : neighbors) {\n        GapSolution newSolution = neighbor.getNewSolution();\n        int mutatedTaskIdx = neighbor.getMutatedTaskIdx();\n        int newAgentIdx = neighbor.getNewAgentIdx();\n\n        if (this.tabuTable[mutatedTaskIdx][newAgentIdx] &lt; iter) {\n          // this move is not tabooed, proceed\n          currSolution = newSolution;\n          currSolutionUpdated = true;\n          this.tabuTable[mutatedTaskIdx][newAgentIdx] = iter + tabuLength;\n\n          if (currSolution.getObjective() &lt; this.bestSolution.getObjective()) {\n            this.bestSolution = currSolution;\n            bestSolutionUpdated = true;\n            break;\n          }\n        } else {\n          // check aspiration criterion\n          if (newSolution.getObjective() &lt; bestSolution.getObjective()) {\n            currSolution = newSolution;\n            bestSolution = currSolution;\n            currSolutionUpdated = true;\n            bestSolutionUpdated = true;\n            this.tabuTable[mutatedTaskIdx][newAgentIdx] = iter + tabuLength;\n            break;\n          }\n        }\n      }\n\n      // in case no move is possible, choose the best neighbor\n      if (!currSolutionUpdated) {\n        GapSolutionNeighbor neighbor = neighbors.getFirst();\n        currSolution = neighbor.getNewSolution();\n        this.tabuTable[neighbor.getMutatedTaskIdx()][neighbor.getNewAgentIdx()] = iter + tabuLength;\n      }\n\n      iter++;\n      this.perfRecords.add(new PerfRecord&lt;&gt;(iter,\n        currSolution.getObjective(),\n        bestSolution.getObjective()));\n\n      // check stopping criteria\n      iterNoImprove = bestSolutionUpdated ? 0 : iterNoImprove + 1;\n      if (iter &gt;= maxIter || iterNoImprove &gt;= maxIterNoImprove) {\n        break;\n      }\n    }\n  }\n\n  public void savePerfRecords(String filename) {\n    PerfRecordsWriter.write(filename, perfRecords);\n  }\n\n  public static void main(String[] args) {\n    String filename = \"/Users/klian/dev/metaheuristics-java-code/src/main/resources/data/gap/gap1.txt\";\n    String outputFilename = \"/Users/klian/dev/books/metaheuristics-java/data/gap/perf_records.txt\";\n    List&lt;GapInstance&gt; instances = GapInstanceReader.read(filename);\n\n    GapInstance instance = instances.get(1);\n    GapTabuSearch tabuSearch = new GapTabuSearch(instance);\n    tabuSearch.solve();\n    tabuSearch.savePerfRecords(outputFilename);\n  }\n}\n\n\n\n8.2.3 Performance on benchmarking instances\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv(\"/Users/klian/dev/books/metaheuristics-java/data/gap/perf_records.csv\", names=['iteration', 'curr_obj', 'best_obj'])\n\n\ndf\n\n\n\n\n\n\n\n\n\niteration\ncurr_obj\nbest_obj\n\n\n\n\n0\n0\n79294\n79294\n\n\n1\n1\n56291\n56291\n\n\n2\n2\n43294\n43294\n\n\n3\n3\n32300\n32300\n\n\n4\n4\n29306\n29306\n\n\n...\n...\n...\n...\n\n\n554\n554\n7294\n273\n\n\n555\n555\n1291\n273\n\n\n556\n556\n3297\n273\n\n\n557\n557\n1291\n273\n\n\n558\n558\n6288\n273\n\n\n\n\n559 rows × 3 columns\n\n\n\n\n\nfig, ax = plt.subplots(1, 1, figsize=(12, 4))\nax.plot(df['iteration'], df['curr_obj'], 'g--', label=\"current objective\")\nax.plot(df['iteration'], df['best_obj'], 'r--', label=\"best objective\")\nax.legend()\n\nax.set_xlim([0, 100])\nax.set_ylim([0, 80000])",
    "crumbs": [
      "Generalized Assignment Problem",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tabu Search for Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "9  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Summary</span>"
    ]
  }
]